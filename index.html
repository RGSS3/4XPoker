<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文明4X扑克</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        land: '#8BC34A',    // 陆地绿色
                        ocean: '#03A9F4',   // 海洋蓝色
                        desert: '#FFC107',  // 沙漠黄色
                        sky: '#9C27B0',     // 天空紫色
                        unexplored: '#9E9E9E', // 未探索灰色
                        explored: '#E0E0E0',   // 已探索白色
                        occupied: '#2196F3',   // 已占领蓝色
                        echo: '#4CAF50',     // 回声区域绿色
                        wonder: '#8BC34A',   // 奇观区域浅绿色
                        combat: '#F44336',   // 战斗区域红色
                        disaster: '#FF5722'  // 灾难区域橙色
                    }
                }
            }
        }
    </script>
    <style>
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        .card-fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .card-fade-out {
            animation: fadeOut 0.3s ease-in-out;
        }
        
        .card {
            aspect-ratio: 2/3;
            perspective: 1000px;
        }
        
        .card-inner {
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }
        
        .card-front, .card-back {
            backface-visibility: hidden;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
        }
        
        .card-back {
            transform: rotateY(180deg);
            background-image: repeating-linear-gradient(45deg, rgba(93, 92, 222, 0.1) 0, rgba(93, 92, 222, 0.1) 10px, transparent 10px, transparent 20px);
        }
        
        .dark .card-back {
            background-image: repeating-linear-gradient(45deg, rgba(93, 92, 222, 0.2) 0, rgba(93, 92, 222, 0.2) 10px, transparent 10px, transparent 20px);
        }
        
        /* 花色颜色定义 */
        .heart {
            color: #E53E3E; /* 红色 */
        }
        
        .dark .heart {
            color: #FC8181; /* 深色模式下的红色 */
        }
        
        .diamond {
            color: #ED8936; /* 橙色 */
        }
        
        .dark .diamond {
            color: #F6AD55; /* 深色模式下的橙色 */
        }
        
        .spade {
            color: #805AD5; /* 紫色 */
        }
        
        .dark .spade {
            color: #9F7AEA; /* 深色模式下的紫色 */
        }
        
        .club {
            color: #2D3748; /* 深灰色/黑色 */
        }
        
        .dark .club {
            color: #E2E8F0; /* 深色模式下的灰白色 */
        }

        /* 游戏板区域类型样式 */
        .region-unexplored {
            background-color: theme('colors.unexplored');
        }
        
        .region-explored {
            background-color: theme('colors.explored');
        }
        
        .region-occupied {
            background-color: theme('colors.occupied');
        }
        
        .region-echo {
            background-color: theme('colors.echo');
        }
        
        /* 奇观样式 - 使用白色背景和加粗彩色边框 */
        .wonder-orange {
            background-color: #FFFFFF;
            color: #000;
            border: 6px solid #FF9800;
            box-shadow: 0 0 0 2px #FF9800, inset 0 0 0 1px #FF9800;
            position: relative;
            z-index: 1;
        }
        
        .wonder-purple {
            background-color: #FFFFFF;
            color: #000;
            border: 6px solid #9C27B0;
            box-shadow: 0 0 0 2px #9C27B0, inset 0 0 0 1px #9C27B0;
            position: relative;
            z-index: 1;
        }
        
        .wonder-blue {
            background-color: #FFFFFF;
            color: #000;
            border: 6px solid #2196F3;
            box-shadow: 0 0 0 2px #2196F3, inset 0 0 0 1px #2196F3;
            position: relative;
            z-index: 1;
        }
        
        .dark .wonder-orange {
            background-color: #1a1a1a;
            color: #fff;
            border: 6px solid #FF9800;
            box-shadow: 0 0 0 2px #FF9800, inset 0 0 0 1px #FF9800;
        }
        
        .dark .wonder-purple {
            background-color: #1a1a1a;
            color: #fff;
            border: 6px solid #9C27B0;
            box-shadow: 0 0 0 2px #9C27B0, inset 0 0 0 1px #9C27B0;
        }
        
        .dark .wonder-blue {
            background-color: #1a1a1a;
            color: #fff;
            border: 6px solid #2196F3;
            box-shadow: 0 0 0 2px #2196F3, inset 0 0 0 1px #2196F3;
        }
        
        /* 奇观闪光效果 */
        .wonder-orange::before, .wonder-purple::before, .wonder-blue::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: inherit;
            z-index: -1;
        }
        
        .wonder-orange::before {
            box-shadow: 0 0 10px 2px rgba(255, 152, 0, 0.6);
        }
        
        .wonder-purple::before {
            box-shadow: 0 0 10px 2px rgba(156, 39, 176, 0.6);
        }
        
        .wonder-blue::before {
            box-shadow: 0 0 10px 2px rgba(33, 150, 243, 0.6);
        }
        
        /* 战争区域样式 */
        .combat-orange {
            background-color: rgba(255, 152, 0, 0.1);
            color: #000;
            border: 3px solid #FF9800;
            position: relative;
            z-index: 1;
        }
        
        .combat-purple {
            background-color: rgba(156, 39, 176, 0.1);
            color: #000;
            border: 3px solid #9C27B0;
            position: relative;
            z-index: 1;
        }
        
        .combat-blue {
            background-color: rgba(33, 150, 243, 0.1);
            color: #000;
            border: 3px solid #2196F3;
            position: relative;
            z-index: 1;
        }
        
        .dark .combat-orange {
            background-color: rgba(255, 152, 0, 0.2);
            color: #fff;
            border: 3px solid #FF9800;
        }
        
        .dark .combat-purple {
            background-color: rgba(156, 39, 176, 0.2);
            color: #fff;
            border: 3px solid #9C27B0;
        }
        
        .dark .combat-blue {
            background-color: rgba(156, 39, 176, 0.2);
            color: #fff;
            border: 3px solid #2196F3;
        }
        
        /* 探索线路样式 */
        .path-land {
            border-left: 4px solid theme('colors.land');
        }
        
        .path-ocean {
            border-left: 4px solid theme('colors.ocean');
        }
        
        .path-desert {
            border-left: 4px solid theme('colors.desert');
        }
        
        .path-sky {
            border-left: 4px solid theme('colors.sky');
        }
        
        /* 手牌悬停效果 */
        .hand-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        
        /* Ensure all inputs have at least 16px font size on mobile */
        @media (max-width: 768px) {
            input, button, select, textarea {
                font-size: 16px !important;
            }
        }
        
        /* Disable text selection for the game interface */
        body {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        /* Re-enable text selection for input elements */
        input, textarea {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <!-- 游戏标题和信息 -->
        <div class="text-center mb-4">
            <h1 class="text-3xl font-bold mb-2" data-i18n="gameTitle">文明4X扑克</h1>
            <p class="text-sm md:text-base text-gray-600 dark:text-gray-400 mb-2" data-i18n="gameDescription">探索、扩张、开发、征服！使用扑克牌建立您的文明</p>
        </div>
        
        <!-- 种子输入区域 -->
        <div class="flex flex-col md:flex-row justify-center items-center mb-4 gap-2">
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-3 shadow-md flex-grow max-w-xl w-full">
                <div class="flex flex-wrap gap-2 items-center">
                    <label for="seed-input" class="font-bold text-sm whitespace-nowrap">游戏种子:</label>
                    <div class="flex flex-1 min-w-0">
                        <input 
                            id="seed-input" 
                            type="text" 
                            class="flex-1 min-w-0 text-base p-2 border border-gray-300 dark:border-gray-600 rounded-l-md bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200"
                            placeholder="输入种子值或使用随机种子" 
                            value="" 
                            spellcheck="false"
                        />
                        <button id="random-seed-btn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 px-3 py-2 rounded-r-md text-gray-700 dark:text-gray-300 flex items-center">
                            🎲
                        </button>
                    </div>
                    <button id="start-seed-game" class="bg-primary hover:bg-indigo-700 text-white px-4 py-2 rounded-lg whitespace-nowrap">
                        开始游戏
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 游戏控制和信息 -->
        <div class="flex flex-wrap justify-between items-center mb-4 gap-2">
            <!-- 得分和回合信息 -->
            <div class="flex flex-col bg-gray-100 dark:bg-gray-800 rounded-lg p-2 shadow-md">
                <div class="flex items-center space-x-4">
                    <div class="text-xl font-bold"><span data-i18n="score">得分</span>: <span id="score" class="text-primary">0</span></div>
                    <div class="text-lg"><span data-i18n="turn">回合</span>: <span id="turn-counter">1</span></div>
                </div>
                <div class="text-sm text-gray-600 dark:text-gray-400 flex space-x-3">
                    <div><span data-i18n="remainingCards">牌堆</span>: <span id="remaining-cards">47</span></div>
                    <div><span>弃牌堆</span>: <span id="discard-count">0</span></div>
                </div>
            </div>
            
            <!-- 种子信息和分享 -->
            <div class="flex items-center bg-gray-100 dark:bg-gray-800 rounded-lg p-2 shadow-md">
                <span class="mr-2 text-sm" data-i18n="randomSeed">随机种子</span>
                <code id="seed-display" class="bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded text-xs break-all mr-2"></code>
                <div class="flex space-x-1">
                    <button id="random-seed" class="text-primary hover:text-primary-dark p-1 rounded text-xs" title="生成随机种子">🎲</button>
                    <button id="input-seed" class="text-primary hover:text-primary-dark p-1 rounded text-xs" title="输入种子">⌨️</button>
                    <button id="copy-seed" class="text-primary hover:text-primary-dark p-1 rounded text-xs" title="复制种子">📋</button>
                    <button id="share-game" class="text-primary hover:text-primary-dark p-1 rounded text-xs" title="分享游戏">↗️</button>
                </div>
            </div>
            
            <!-- 游戏控制按钮 -->
            <div class="flex space-x-2">
                <button id="new-game-btn" class="bg-primary hover:bg-indigo-700 text-white px-3 py-1 rounded-lg text-sm">
                    <span data-i18n="newGame">新游戏</span>
                </button>
                <button id="undo-btn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 px-3 py-1 rounded-lg text-sm opacity-50" disabled>
                    <span data-i18n="undo">撤销</span>
                </button>
                <button id="history-btn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 px-3 py-1 rounded-lg text-sm">
                    <span data-i18n="history">历史</span>
                </button>
            </div>
        </div>
        
        <!-- 游戏区域 -->
        <div class="flex flex-col md:flex-row gap-4" style="margin-bottom: 60px">
            <!-- 主游戏区域 -->
            <div class="w-full md:w-3/4 bg-gray-100 dark:bg-gray-800 rounded-lg px-1 py-4 md:p-4 shadow-md">
                <div class="">
                    <!-- 游戏区域：4列13行布局 -->
                    <div class="flex justify-center">
                        <div class="grid grid-cols-4 gap-2" style="width: fit-content">
                            <!-- 路径标题 -->
                            <div class="bg-land text-white rounded px-2 py-1 text-center font-bold w-16 md:w-20 mx-auto flex items-center justify-center">陆地</div>
                            <div class="bg-ocean text-white rounded px-2 py-1 text-center font-bold w-16 md:w-20 mx-auto flex items-center justify-center">海洋</div>
                            <div class="bg-desert text-white rounded px-2 py-1 text-center font-bold w-16 md:w-20 mx-auto flex items-center justify-center">沙漠</div>
                            <div class="bg-sky text-white rounded px-2 py-1 text-center font-bold w-16 md:w-20 mx-auto flex items-center justify-center">天空</div>
                            
                            <!-- 游戏区域格子 -->
                            <div id="land-regions" class="flex flex-col gap-1">
                                <!-- 陆地区域将通过JS动态生成 -->
                            </div>
                            <div id="ocean-regions" class="flex flex-col gap-1">
                                <!-- 海洋区域将通过JS动态生成 -->
                            </div>
                            <div id="desert-regions" class="flex flex-col gap-1">
                                <!-- 沙漠区域将通过JS动态生成 -->
                            </div>
                            <div id="sky-regions" class="flex flex-col gap-1">
                                <!-- 天空区域将通过JS动态生成 -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 右侧信息和操作区 -->
            <div class="w-full md:w-1/4 flex flex-col gap-4">
                <!-- 游戏消息区 -->
                <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-3 shadow-md h-24 overflow-y-auto">
                    <h3 class="text-sm font-bold mb-1 text-gray-700 dark:text-gray-300" data-i18n="gameMessages">游戏消息</h3>
                    <div id="game-message" class="text-sm"></div>
                </div>
                
                <!-- 行动区 -->
                <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-3 shadow-md">
                    <h3 class="text-sm font-bold mb-2 text-gray-700 dark:text-gray-300" data-i18n="actions">行动</h3>
                    <div class="space-y-2">
                        <div class="text-sm mb-2 text-gray-600 dark:text-gray-400 text-center">
                            <p data-i18n="selectCardFirst">先选择手牌，再点击区域</p>
                        </div>
                        <div class="text-xs text-gray-500 dark:text-gray-400 mt-2">
                            <ul class="list-disc list-inside">
                                <li>探索需要点数≥格子等级的卡牌</li>
                                <li>黑桃探索时点数翻倍</li>
                                <li>红桃占领时得分提高</li>
                                <li>手牌上限：<span id="rules-hand-limit">10</span>张 (人口奇观可提高)</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <!-- 游戏日志 -->
                <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-3 shadow-md flex-grow overflow-y-auto">
                    <h3 class="text-sm font-bold mb-1 text-gray-700 dark:text-gray-300" data-i18n="gameLog">游戏日志</h3>
                    <div id="game-log" class="text-xs space-y-1 h-40 overflow-y-auto"></div>
                </div>
            </div>
        </div>
        
        <!-- 当前选择的行动提示 -->
        <div id="action-info" class="text-center text-sm text-gray-600 dark:text-gray-400 h-6 mt-2 mb-20"></div>
        
        <!-- 浮动手牌区域 -->
        <div class="fixed bottom-0 left-0 right-0 z-40 bg-white dark:bg-gray-900 border-t border-gray-200 dark:border-gray-700 shadow-lg">
            <div class="container mx-auto px-4 py-2 max-w-6xl">
                <!-- 状态信息行 -->
                <div class="flex justify-between items-center mb-1">
                    <div class="flex items-center space-x-2">
                        <div class="text-sm"><span>得分</span>: <span id="float-score" class="text-primary font-bold">0</span></div>
                        <div class="text-sm border-l border-gray-300 dark:border-gray-700 pl-2"><span>回合</span>: <span id="float-turn">1</span></div>
                        <div class="text-sm border-l border-gray-300 dark:border-gray-700 pl-2"><span>牌堆</span>: <span id="float-deck">47</span></div>
                        <div class="text-sm border-l border-gray-300 dark:border-gray-700 pl-2"><span>弃牌</span>: <span id="float-discard">0</span></div>
                        <div class="text-sm border-l border-gray-300 dark:border-gray-700 pl-2 text-green-600 dark:text-green-400">
                            <span>每回合</span>: <span id="float-points-per-turn">+0</span>
                        </div>
                        <div class="text-sm border-l border-gray-300 dark:border-gray-700 pl-2 text-yellow-600 dark:text-yellow-400">
                            <span>预计</span>: ≈<span id="estimated-score">0</span>
                        </div>
                    </div>
                    <div class="flex space-x-2">
                        <button id="discard-btn" class="bg-red-500 hover:bg-red-600 text-white py-1 px-3 rounded-lg text-sm flex items-center">
                            <span>弃牌</span>
                            <span class="ml-1 text-xs opacity-75">(<span id="selected-count">0</span>张)</span>
                        </button>
                        <button id="end-turn-btn" class="bg-yellow-600 hover:bg-yellow-700 text-white py-1 px-3 rounded-lg text-sm">
                            <span data-i18n="endTurn">结束回合</span>
                        </button>
                    </div>
                </div>
                
                <!-- 手牌区域 -->
                <div class="flex flex-col">
                    <h3 class="text-lg font-bold mb-1" data-i18n="yourHand">您的手牌</h3>
                    <div id="hand-container" class="flex justify-center gap-2 flex-wrap p-2 bg-gray-100 dark:bg-gray-800 rounded-lg min-h-[120px] relative">
                        <!-- 手牌将在这里动态生成 -->
                    </div>
                    <div class="text-xs text-right mt-1 text-gray-500 dark:text-gray-400">
                        手牌: <span id="hand-count">0</span>/<span id="hand-limit">10</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 右下角信息栏 -->
        <div class="fixed bottom-4 right-4 z-30">
            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-2 shadow-md">
                <div class="flex items-center space-x-3">
                    <div class="font-bold text-sm"><span>得分</span>: <span id="score-corner" class="text-primary">0</span></div>
                    <div class="text-sm"><span>回合</span>: <span id="turn-corner">1</span></div>
                </div>
                <div class="text-xs text-gray-600 dark:text-gray-400 flex space-x-2">
                    <div><span>牌堆</span>: <span id="remaining-corner">47</span></div>
                    <div><span>弃牌</span>: <span id="discard-corner">0</span></div>
                </div>
                <div class="text-xs mt-1 font-semibold text-green-600 dark:text-green-400">
                    <span>每回合</span>: <span id="points-per-turn">+0</span>分
                </div>
            </div>
        </div>
        
        <!-- 路径征服提示弹窗 -->
        <div id="conquest-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4 text-center transform scale-100 transition-transform duration-300">
                <h2 class="text-2xl font-bold mb-4 text-yellow-500 dark:text-yellow-400">征服成就!</h2>
                <p id="conquest-message" class="text-lg mb-6"></p>
                <p class="mb-4 text-primary font-bold text-xl">+<span id="conquest-points">0</span>分</p>
                <button id="conquest-close" class="bg-primary hover:bg-indigo-700 text-white px-4 py-2 rounded-lg">
                    继续游戏
                </button>
            </div>
        </div>
        
        <!-- 游戏结果弹窗 -->
        <div id="result-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
                <h2 class="text-2xl font-bold mb-4 text-center" data-i18n="gameOver">游戏结束</h2>
                <p class="text-lg mb-2"><span data-i18n="finalScore">最终得分</span>: <span id="final-score" class="font-bold"></span></p>
                <p class="mb-4 text-sm text-gray-600 dark:text-gray-400" data-i18n="playAgainPrompt">再来一次，创建更强大的文明！</p>
                <div class="flex flex-wrap justify-center gap-2">
                    <button id="play-again" class="bg-primary hover:bg-indigo-700 text-white px-4 py-2 rounded-lg" data-i18n="newGame">新游戏</button>
                    <button id="replay-same-seed" class="bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg" data-i18n="replaySameSeed">重玩本局</button>
                    <button id="share-result" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg" data-i18n="shareResult">分享成绩</button>
                </div>
            </div>
        </div>
        
        <!-- 历史浏览器弹窗 -->
        <div id="history-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto">
                <h2 class="text-xl font-bold mb-4 text-center" data-i18n="historyBrowser">历史浏览器</h2>
                <div class="flex justify-between items-center mb-2">
                    <div class="text-sm">
                        <span data-i18n="turn">回合</span>: <span id="history-turn" class="font-bold">1</span> / 
                        <span data-i18n="move">操作</span>: <span id="history-index" class="font-bold">0</span> / <span id="history-total" class="font-bold">0</span>
                    </div>
                    <div class="text-sm">
                        <span data-i18n="score">得分</span>: <span id="history-score" class="font-bold">0</span>
                    </div>
                </div>
                
                <!-- 浏览控制 -->
                <div class="flex justify-between items-center mb-3">
                    <button id="history-prev" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 py-2 px-4 rounded-lg text-sm flex items-center">
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                        </svg>
                    </button>
                    <div class="text-center">
                        <span id="history-action-desc" class="text-sm"></span>
                    </div>
                    <button id="history-next" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 py-2 px-4 rounded-lg text-sm flex items-center">
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                        </svg>
                    </button>
                </div>
                
                <!-- 历史状态显示 -->
                <div id="history-board" class="bg-white dark:bg-gray-900 rounded-lg p-1 md:p-2 mb-4">
                    <!-- 历史状态将在这里动态显示 -->
                </div>
                
                <!-- 导出按钮 -->
                <div class="flex justify-center gap-2 mb-4">
                    <button id="export-html" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded-lg text-sm flex items-center">
                        <svg class="w-4 h-4 mr-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                        </svg>
                        <span>HTML</span>
                    </button>
                    <button id="export-txt" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-lg text-sm flex items-center">
                        <svg class="w-4 h-4 mr-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                        </svg>
                        <span>TXT</span>
                    </button>
                </div>
                
                <!-- 控制按钮 -->
                <div class="flex justify-center gap-3">
                    <button id="history-select" class="bg-primary hover:bg-indigo-700 text-white px-4 py-2 rounded-lg" data-i18n="selectThis">选择此状态</button>
                    <button id="history-cancel" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 px-4 py-2 rounded-lg" data-i18n="cancel">取消</button>
                </div>
            </div>
        </div>
        
        <!-- 提示弹窗 -->
        <div id="toast" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-lg opacity-0 transition-opacity duration-300 z-50">
            <!-- 提示内容 -->
        </div>

        <script>
            // 游戏常量
            const SUITS = ['heart', 'diamond', 'spade', 'club'];
            const SUIT_SYMBOLS = {
                'heart': '♥',
                'diamond': '♦',
                'spade': '♠',
                'club': '♣'
            };
            const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const RANK_VALUES = {
                'A': 14, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,
                '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
            };
            
            // 路径定义
            const PATHS = ['land', 'ocean', 'desert', 'sky'];
            const PATH_NAMES = {
                'land': '陆地',
                'ocean': '海洋',
                'desert': '沙漠',
                'sky': '天空'
            };
            
            // 区域类型
            const REGION_TYPES = {
                'standard': {
                    name: '普通区域',
                    color: 'explored',
                    explorePoints: 1,
                    occupyPoints: 1
                },
                'echo': {
                    name: '回声区域',
                    color: 'echo',
                    explorePoints: 1,
                    // occupyPoints在占领时计算（= 牌值 x 2）
                },
                'wonder': {
                    name: '奇观区域',
                    color: 'wonder',
                    explorePoints: 2,
                    // 奇观有特殊占领逻辑和效果
                },
                'combat': {
                    name: '战争区域',
                    color: 'combat',
                    explorePoints: 2,
                    // 战争区域有特殊解除逻辑和效果
                },
                'forgotten': {
                    name: '遗忘区域',
                    color: 'explored',
                    explorePoints: 1,
                    occupyPoints: 0  // 遗忘区域占领不提供分数
                }
            };
            
            // 奇观强度级别
            const WONDER_TIERS = {
                'orange': { color: 'orange', name: '橙级奇观', baseScore: 7, effectMultiplier: 3 },
                'purple': { color: 'purple', name: '紫级奇观', baseScore: 5, effectMultiplier: 2 },
                'blue': { color: 'blue', name: '蓝级奇观', baseScore: 3, effectMultiplier: 1 }
            };
            
            // 奇观名称列表（七大奇迹和SCP七大地点）
            const WONDER_NAMES = [
                '亚历山大港灯塔', '巴比伦空中花园', '奥林匹亚宙斯像', 
                '阿尔忒弥斯神庙', '摩索拉斯陵墓', '罗德岛太阳神巨像', 
                '亚历山大图书馆', '金字塔', '万里长城', '埃菲尔铁塔',
                'SCP-2000 复兴', 'SCP-3000 深海巨蛇', 'SCP-1000 远古森林',
                'SCP-2317 破碎之门', 'SCP-3999 终焉之地', 'SCP-4000 遗忘森林',
                'SCP-001 守门人'
            ];
            
            // 战争区域名称列表（古今中外经典战争）
            const WAR_NAMES = [
                '特洛伊战争', '马拉松战役', '温泉关战役', '萨拉米斯海战', 
                '楚汉之争', '赤壁之战', '官渡之战', '长平之战', 
                '十字军东征', '百年战争', '三十年战争', '拿破仑战争',
                '普法战争', '库图佐夫战役', '斯大林格勒战役', '诺曼底登陆',
                '朝鲜战争', '太平洋战争', '珍珠港事件', '沙丘之战'
            ];
            const COMBAT_CHECK_FUNCTIONS = {
                checkPair: cards => {
                    if (cards.length !== 2) return false;
                    const counts = {};
                    for (const card of cards) {
                        counts[card.rank] = (counts[card.rank] || 0) + 1;
                    }
                    return Object.values(counts).some(count => count >= 2);
                },
                checkAceAny: cards => cards.some(card => card.rank === 'A') && cards.length === 2,
                checkThreeKind: cards => findSameRankCards(cards, 3) && cards.length === 3,
                checkTwoPair: cards => {
                    if (cards.length !== 4) return false;
                    const counts = {};
                    for (const card of cards) {
                        counts[card.rank] = (counts[card.rank] || 0) + 1;
                    }
                    let pairCount = 0;
                    for (const rank in counts) {
                        if (counts[rank] >= 2) {
                            pairCount++;
                        }
                    }
                    return pairCount >= 2;
                },
                checkFlush: cards => {
                    if (cards.length !== 4) return false;
                    const suits = cards.map(card => card.suit);
                    const suitCounts = {};
                    for (const suit of suits) {
                        suitCounts[suit] = (suitCounts[suit] || 0) + 1;
                    }
                    return Object.values(suitCounts).some(count => count >= 4);
                },
                checkStraight: cards => {
                    if (cards.length !== 4) return false;
                    const values = cards.map(card => RANK_VALUES[card.rank]);
                    const uniqueValues = [...new Set(values)].sort((a, b) => a - b);
                    for (let i = 0; i <= uniqueValues.length - 4; i++) {
                        let isStraight = true;
                        for (let j = 0; j < 3; j++) {
                            if (uniqueValues[i + j + 1] !== uniqueValues[i + j] + 1) {
                                isStraight = false;
                                break;
                            }
                        }
                        if (isStraight) return true;
                    }
                    const hasAce = values.includes(14);
                    const has2 = values.includes(2);
                    const has3 = values.includes(3);
                    const has4 = values.includes(4);
                    if (hasAce && has2 && has3 && has4) {
                        return true;
                    }
                    return false;
                },
                checkFourKind: cards => findSameRankCards(cards, 4) && cards.length === 4
            };
            
            // 战争区域解除代价类型及其权重
            const COMBAT_REQUIREMENTS = {
                'blue': [
                    {
                        type: 'pair', name: '一对', display: '任意一对', weight: 2,
                        checkFnName: 'checkPair' // Store the key
                    },
                    {
                        type: 'ace_any', name: 'A+任意一张牌', display: 'A+任意一张牌', weight: 1,
                        checkFnName: 'checkAceAny' // Store the key
                    }
                ],
                'purple': [
                    {
                        type: 'three_kind', name: '三条', display: '三张相同点数', weight: 2,
                        checkFnName: 'checkThreeKind' // Store the key
                    },
                    {
                        type: 'two_pair', name: '两对', display: '两对不同点数', weight: 2,
                        checkFnName: 'checkTwoPair' // Store the key
                    }
                ],
                'orange': [
                    {
                        type: 'flush', name: '同花', display: '四张同花色', weight: 2,
                        checkFnName: 'checkFlush' // Store the key
                    },
                    {
                        type: 'straight', name: '顺子', display: '四张连续点数', weight: 2,
                        checkFnName: 'checkStraight' // Store the key
                    },
                    {
                        type: 'four_kind', name: '四条', display: '四张相同点数', weight: 1,
                        checkFnName: 'checkFourKind' // Store the key
                    }
                ]
            };
            

            // 辅助函数：检查牌组中是否有指定数量的同点数牌 (这个函数本身是正确的)
            function findSameRankCards(cards, count) {
                const rankCounts = {};
                for (const card of cards) {
                    rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
                }
                return Object.values(rankCounts).some(c => c >= count);
            }
            
            // 战争区域不解除的负面效果类型及其权重
           const COMBAT_EFFECTS = [
                {type: 'occupy_loss', name: '沦陷', weight: 3,
                    description: '移除本路径上{count}张回合得分最高的占领卡，不包括奇迹'},
                {type: 'wonder_loss', name: '奇迹沦陷', weight: 2,
                    description: '从上往下移除本路径上{count}张奇迹的占领卡'},
                {type: 'income_loss', name: '掠夺', weight: 2,
                    description: '本回合损失该路径收入的{multiplier}倍 (蓝:3x, 紫:5x, 橙:10x)'}, // <-- 修改这里
                {type: 'exploration_loss', name: '模因入侵', weight: 1,
                    description: '直接把这条路径最上面{count}个探索/占领区域变为未探索状态，如有占领牌直接弃牌'},
                {type: 'area_loss', name: '未来破坏', weight: 1,
                    description: '把这张卡上方的{count}个格子直接变为遗忘格子'}
            ];
            
            // 奇观效果类型及其权重
            const WONDER_EFFECTS = [
                { type: 'draw', name: '抽卡', weight: 4, description: '每回合额外抽牌' },
                { type: 'score', name: '得分', weight: 6, description: '每回合额外得分' },
                { type: 'explore', name: '探索', weight: 2, description: '占领时额外探索该路径上的格子' },
                { type: 'population', name: '人口', weight: 3, description: '增加手牌上限' },
                { type: 'heart_bonus', name: '红桃收获', weight: 2, description: '该路径上每个红桃占领每回合+2分' },
                { type: 'spade_bonus', name: '黑桃收获', weight: 2, description: '该路径上每个黑桃占领每回合+2分' },
                { type: 'diamond_bonus', name: '方片收获', weight: 2, description: '该路径上每个方片占领每回合+2分' },
                { type: 'club_bonus', name: '梅花收获', weight: 2, description: '该路径上每个梅花占领每回合+2分' }
            ];
            
            // 多语言支持
            const LANGUAGES = {
                'zh-CN': {
                    name: '中文',
                    gameTitle: '文明4X扑克',
                    gameDescription: '探索、扩张、开发、征服！使用扑克牌建立您的文明',
                    score: '得分',
                    turn: '回合',
                    remainingCards: '剩余牌数',
                    randomSeed: '随机种子',
                    newGame: '新游戏',
                    undo: '撤销',
                    history: '历史',
                    gameMessages: '游戏消息',
                    actions: '行动',
                    explore: '探索',
                    occupy: '占领',
                    endTurn: '结束回合',
                    gameLog: '游戏日志',
                    yourHand: '您的手牌',
                    gameOver: '游戏结束',
                    finalScore: '最终得分',
                    playAgainPrompt: '再来一次，创建更强大的文明！',
                    replaySameSeed: '重玩本局',
                    shareResult: '分享成绩',
                    historyBrowser: '历史浏览器',
                    selectThis: '选择此状态',
                    cancel: '取消',
                    move: '操作',
                    copy: '复制',
                    share: '分享',
                    copied: '已复制到剪贴板',
                    shareText: '我在文明4X扑克游戏中获得了{score}分！随机种子:{seed}，来挑战我吧！',
                    selectCard: '请选择一张手牌',
                    selectRegion: '请选择一个区域',
                    noValidRegion: '没有有效的区域可以选择',
                    exploreDone: '探索成功！获得{points}分',
                    occupyDone: '占领成功！每回合获得{points}分',
                    turnEnded: '回合结束，获得{points}分',
                    cardDrawn: '抽了一张牌：{rank}{suit}',
                    gameStart: '游戏开始！起始手牌：5张',
                    notEnoughRank: '卡牌点数不足以探索该区域',
                    alreadyOccupied: '该区域已被占领',
                    notExplored: '该区域尚未探索',
                    infoSelectCardToExplore: '请选择一张手牌进行探索',
                    infoSelectCardToOccupy: '请选择一张手牌进行占领',
                    pathLand: '陆地',
                    pathOcean: '海洋',
                    pathDesert: '沙漠',
                    pathSky: '天空',
                    standardRegion: '普通区域',
                    echoRegion: '回声区域',
                    exploredRegion: '已探索',
                    unexploredRegion: '未探索',
                    occupiedRegion: '已占领',
                    regionRank: '区域等级',
                    scoreThisTurn: '本回合得分',
                    totalScore: '总得分',
                    extraPoints: '额外点数',
                    heartBonus: '红心加成',
                    spadeBonus: '黑桃加成',
                    echoBonus: '回声加成',
                    exportSuccess: '导出成功',
                    forgottenRegion: '遗忘区域', // <-- Add this
                    clickToResolveCombat: '点击解除', // <-- Add this
                    combatEffectOccupyLoss: '移除本路径上{count}张回合得分最高的占领卡，不包括奇迹',
                    combatEffectWonderLoss: '从上往下移除本路径上{count}张奇迹的占领卡',
                    combatEffectIncomeLoss: '本回合损失该路径收入的{multiplier}倍 (蓝:3x, 紫:5x, 橙:10x)', // <-- 修改这里
                    combatEffectExplorationLoss: '直接把这条路径最上面{count}个探索/占领区域变为未探索状态，如有占领牌直接弃牌', // Clarified to include occupied
                    combatEffectAreaLoss: '把这张卡上方的{count}个格子直接变为遗忘格子',
                },
                'en': {
                    name: 'English',
                    gameTitle: 'Civilization 4X Poker',
                    gameDescription: 'Explore, Expand, Exploit, Exterminate! Build your civilization with poker cards',
                    score: 'Score',
                    turn: 'Turn',
                    remainingCards: 'Cards Left',
                    randomSeed: 'Random Seed',
                    newGame: 'New Game',
                    undo: 'Undo',
                    history: 'History',
                    gameMessages: 'Game Messages',
                    actions: 'Actions',
                    explore: 'Explore',
                    occupy: 'Occupy',
                    endTurn: 'End Turn',
                    gameLog: 'Game Log',
                    yourHand: 'Your Hand',
                    gameOver: 'Game Over',
                    finalScore: 'Final Score',
                    playAgainPrompt: 'Play again to build an even greater civilization!',
                    replaySameSeed: 'Replay Same Game',
                    shareResult: 'Share Result',
                    historyBrowser: 'History Browser',
                    selectThis: 'Select This State',
                    cancel: 'Cancel',
                    move: 'Move',
                    copy: 'Copy',
                    share: 'Share',
                    copied: 'Copied to clipboard',
                    shareText: 'I scored {score} points in Civilization 4X Poker! Random seed:{seed}, challenge me!',
                    selectCard: 'Please select a card from your hand',
                    selectRegion: 'Please select a region',
                    noValidRegion: 'No valid region to select',
                    exploreDone: 'Exploration successful! Gained {points} points',
                    occupyDone: 'Occupation successful! Gain {points} points per turn',
                    turnEnded: 'Turn ended, gained {points} points',
                    cardDrawn: 'Drew a card: {rank}{suit}',
                    gameStart: 'Game started! Initial hand: 5 cards',
                    notEnoughRank: 'Card rank not high enough to explore this region',
                    alreadyOccupied: 'This region is already occupied',
                    notExplored: 'This region is not explored yet',
                    infoSelectCardToExplore: 'Select a card to explore',
                    infoSelectCardToOccupy: 'Select a card to occupy',
                    pathLand: 'Land',
                    pathOcean: 'Ocean',
                    pathDesert: 'Desert',
                    pathSky: 'Sky',
                    standardRegion: 'Standard Region',
                    echoRegion: 'Echo Region',
                    exploredRegion: 'Explored',
                    unexploredRegion: 'Unexplored',
                    occupiedRegion: 'Occupied',
                    regionRank: 'Region Rank',
                    scoreThisTurn: 'Score this turn',
                    totalScore: 'Total score',
                    extraPoints: 'Extra points',
                    heartBonus: 'Heart bonus',
                    spadeBonus: 'Spade bonus',
                    echoBonus: 'Echo bonus',
                    exportSuccess: 'Export successful',
                    forgottenRegion: 'Forgotten Region', // <-- Add this
                    clickToResolveCombat: 'Click to Resolve', // <-- Add this
                    combatEffectOccupyLoss: 'Remove {count} highest scoring occupied cards on this path, excluding wonders',
                    combatEffectWonderLoss: 'Remove {count} occupied wonder cards from top down on this path',
                     combatEffectIncomeLoss: 'Lose {multiplier}x income from this path this turn (Blue:3x, Purple:5x, Orange:10x)', // <-- 修改这里
                    combatEffectExplorationLoss: 'Revert top {count} explored/occupied regions on this path to unexplored, discarding occupied cards', // Clarified
                    combatEffectAreaLoss: 'Convert {count} regions above this card to forgotten regions',
                }
            };
            
            // 游戏状态
            let gameState = {
                deck: [],            // 牌堆
                hand: [],            // 手牌
                discardPile: [],     // 弃牌堆
                score: 0,            // 总分数
                turn: 1,             // 当前回合
                currentSeed: '',     // 当前种子
                selectedCards: [],   // 当前选择的手牌索引数组（支持多选）
                selectedAction: '',  // 当前选择的行动
                regions: {},         // 游戏区域状态
                gameOver: false      // 游戏是否结束
            };
            
            // 历史记录状态
            let history = [];
            let currentHistoryIndex = -1;
            let currentBrowsingIndex = 0;
            
            // 游戏日志数据
            let gameLogData = [];
            
            // 当前语言
            let currentLanguage = 'zh-CN';
            
            // 初始化随机数生成器
            let seededRandom = null;
            
            // DOM元素
            const scoreDisplay = document.getElementById('score');
            const turnCounter = document.getElementById('turn-counter');
            const remainingCardsDisplay = document.getElementById('remaining-cards');
            const handContainer = document.getElementById('hand-container');
            const gameMessageElement = document.getElementById('game-message');
            const actionInfoElement = document.getElementById('action-info');
            const seedDisplay = document.getElementById('seed-display');
            const resultModal = document.getElementById('result-modal');
            const finalScoreDisplay = document.getElementById('final-score');
            const toastElement = document.getElementById('toast');
            const gameLogElement = document.getElementById('game-log');
            
            // 随机加权选择函数
            function weightedRandomSelect(items, weights) {
                const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
                let random = seededRandom() * totalWeight;
                
                for (let i = 0; i < items.length; i++) {
                    random -= weights[i];
                    if (random <= 0) {
                        return items[i];
                    }
                }
                
                // 如果出现舍入误差，返回最后一项
                return items[items.length - 1];
            }
            
            // 创建奇观
            function createWonder(rank) {
                // 为奇观选择一个随机名称
                const wonderNameIndex = Math.floor(seededRandom() * WONDER_NAMES.length);
                const wonderName = WONDER_NAMES[wonderNameIndex];
                
                // 根据等级确定奇观强度，明确指定不同等级对应的奇观类型
                let selectedTierKey;
                if (rank >= 12) {
                    // 12-13级: 必定是橙色奇观
                    selectedTierKey = 'orange';
                } else if (rank >= 9) {
                    // 9-11级: 必定是紫色奇观
                    selectedTierKey = 'purple';
                } else {
                    // 6-8级: 必定是蓝色奇观
                    selectedTierKey = 'blue';
                }
                
                const tier = WONDER_TIERS[selectedTierKey];
                
                // 选择奇观效果
                const effectWeights = WONDER_EFFECTS.map(effect => effect.weight);
                const selectedEffect = weightedRandomSelect(WONDER_EFFECTS, effectWeights);
                
                // 如果是花色收获效果，简化名称显示
                if (selectedEffect.type.includes('_bonus')) {
                    const suit = selectedEffect.type.split('_')[0];
                    selectedEffect.name = SUIT_SYMBOLS[suit];
                }
                
                // 设置统一的占领条件 - 可以使用J、Q、K、A或者任意红心
                const occupyCondition = { 
                    type: 'multiple', 
                    display: 'J、Q、K、A或红心'
                };
                
                return {
                    name: wonderName,
                    tier: selectedTierKey,
                    effect: selectedEffect,
                    occupyCondition: occupyCondition,
                    revealed: false // 未探索前不显示奇观名称
                };
            }
            
            // 检查卡片是否满足奇观的占领条件
            function cardMeetsWonderCondition(card, wonderData) {
                const condition = wonderData.occupyCondition;
                
                if (condition.type === 'rank') {
                    return card.rank === condition.rank;
                } else if (condition.type === 'suit') {
                    return card.suit === condition.suit;
                } else if (condition.type === 'multiple') {
                    // 检查是否是J、Q、K、A或红心
                    return card.rank === 'J' || 
                           card.rank === 'Q' || 
                           card.rank === 'K' || 
                           card.rank === 'A' || 
                           card.suit === 'heart';
                }
                
                return false;
            }
            
            // 创建战争区域
            function createCombatZone(rank) {
                // 为战争区域选择一个随机名称
                const warNameIndex = Math.floor(seededRandom() * WAR_NAMES.length);
                const warName = WAR_NAMES[warNameIndex];
                
                // 根据等级确定战争区域的强度
                let selectedTierKey;
                if (rank >= 10) {
                    // 10-13级: 橙色战争区域（最难）
                    selectedTierKey = 'orange';
                } else if (rank >= 7) {
                    // 7-9级: 紫色战争区域（中等）
                    selectedTierKey = 'purple';
                } else {
                    // 5-6级: 蓝色战争区域（简单）
                    selectedTierKey = 'blue';
                }
                
                // 选择解除要求
                const requirements = COMBAT_REQUIREMENTS[selectedTierKey];
                const reqWeights = requirements.map(req => req.weight);
                const selectedRequirement = weightedRandomSelect(requirements, reqWeights);
                
                // 选择不解除的惩罚效果
                const effectWeights = COMBAT_EFFECTS.map(effect => effect.weight);
                const selectedEffect = weightedRandomSelect(COMBAT_EFFECTS, effectWeights);
                
                // 对于惩罚效果的严重程度，根据战争级别设置数值
                let effectSeverity;
                if (selectedTierKey === 'orange') {
                    effectSeverity = 3; // 最严重
                } else if (selectedTierKey === 'purple') {
                    effectSeverity = 2; // 中等
                } else {
                    effectSeverity = 1; // 轻微
                }
                
                // 对于income_loss（掠夺）效果，设置具体的点数
                let lossPoints = 0;
                if (selectedEffect.type === 'income_loss') {
                    if (selectedTierKey === 'orange') {
                        lossPoints = 10;
                    } else if (selectedTierKey === 'purple') {
                        lossPoints = 5;
                    } else {
                        lossPoints = 3;
                    }
                }
                
                return {
                    name: warName,
                    tier: selectedTierKey,
                    requirement: selectedRequirement,
                    effect: {
                        ...selectedEffect,
                        severity: effectSeverity,
                        points: lossPoints
                    },
                    revealed: false, // 未探索前不显示战争区域详情
                    blocking: true   // 默认阻碍进一步探索
                };
            }
            
            // 检查卡牌组合是否满足战争区域解除条件的辅助函数
            function findSameRankCards(cards, count) {
                const rankCounts = {};
                
                for (const card of cards) {
                    rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
                }
                
                return Object.values(rankCounts).some(c => c >= count);
            }
            
            function getAllStandardCards() {
                const all = [];
                const allSuits = ['heart', 'diamond', 'spade', 'club']; // 方片自己也可以是替换值
                const allRanks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

                for (const suit of allSuits) {
                    for (const rank of allRanks) {
                        all.push({ suit, rank });
                    }
                }
                return all;
            }

            // 所有可能的标准卡牌，只生成一次
            const allPossibleStandardCards = getAllStandardCards();


            // 递归函数：尝试为当前手牌中的方片指定值
            // currentHand: 当前正在尝试的牌组状态（其中方片可能已被替换）
            // diamondIndices: 原始手牌中所有方片的索引数组
            // currentIndexToAssign: diamondIndices 中当前需要处理的方片的索引
            // checkFn: 要检查的模式函数
            function recursiveAssignDiamonds(currentHand, diamondIndices, currentIndexToAssign, checkFn) {
                // 基本情况：所有方片都已经指定了值
                if (currentIndexToAssign >= diamondIndices.length) {
                    // 对最终形成的牌组检查模式
                    return checkFn(currentHand);
                }

                // 获取当前要指定值的方片在原始手牌中的索引
                const originalDiamondIndex = diamondIndices[currentIndexToAssign];

                // 尝试为这个方片指定每一种可能的标准卡牌值
                for (const possibleCard of allPossibleStandardCards) {
                    // 创建一个新牌组，将当前方片替换为 possibleCard
                    const nextHand = currentHand.map((card, idx) => {
                        return idx === originalDiamondIndex ? possibleCard : card;
                    });

                    // 递归调用，处理下一个方片
                    if (recursiveAssignDiamonds(nextHand, diamondIndices, currentIndexToAssign + 1, checkFn)) {
                        return true; // 如果发现了任何一个有效的组合，就返回 true
                    }
                }

                // 如果为当前方片尝试了所有可能值，但都没有找到有效组合，则返回 false
                return false;
            }

            // 检查手牌是否满足特定模式（考虑方片通配符）
            // cards: 玩家当前选择的手牌数组 (Card 对象数组)
            // checkFn: 用于检查模式的函数，接受一个 Card 对象数组作为参数
            function hasPattern(cards, checkFn) {
                // 找到所有方片在传入的 cards 数组中的索引
                const diamondIndices = cards
                    .map((card, index) => ({ card, index }))
                    .filter(item => item.card.suit === 'diamond')
                    .map(item => item.index);

                // 如果没有方片，直接检查模式
                if (diamondIndices.length === 0) {
                    return checkFn(cards);
                }

                // 如果有方片，开始递归分配值并检查模式
                return recursiveAssignDiamonds(cards, diamondIndices, 0, checkFn);
            }
            
            // 初始化游戏区域
            function initializeGameRegions() {
                // 初始化区域数据结构
                gameState.regions = {};
                
                // 为每条路径初始化区域
                for (const pathId of PATHS) {
                    gameState.regions[pathId] = Array(13).fill().map((_, index) => {
                        const rank = index + 1;
                        let type = 'standard';
                        let wonderData = null;
                        let combatData = null;
                        
                        // 区域类型的生成规则
                        
                        // 5-6级有机会生成战争区域
                        if (rank >= 5) {
                            // 100%概率为战争区域, 目前还没有灾难区域
                            const randomVal = seededRandom();
                            if (randomVal < 1) {
                                type = 'combat';
                                combatData = createCombatZone(rank);
                            }
                        }
                        // 7-8级区域
                        else if (rank >= 6 && rank <= 8) {
                            // 30%概率为战争区域, 30%概率为奇观, 20%概率为回声区域, 20%概率为普通区域
                            const randomVal = seededRandom();
                            if (randomVal < 0.3) {
                                type = 'combat';
                                combatData = createCombatZone(rank);
                            } else if (randomVal < 0.6) {
                                type = 'wonder';
                                wonderData = createWonder(rank);
                            } else if (randomVal < 0.8) {
                                type = 'echo';
                            }
                        }
                        // 9级及以上区域
                        else if (rank >= 9) {
                            // 35%概率为战争区域, 35%概率为奇观, 20%概率为回声区域, 10%概率为普通区域
                            const randomVal = seededRandom();
                            if (randomVal < 0.35) {
                                type = 'combat';
                                combatData = createCombatZone(rank);
                            } else if (randomVal < 0.7) {
                                type = 'wonder';
                                wonderData = createWonder(rank);
                            } else if (randomVal < 0.9) {
                                type = 'echo';
                            }
                        }
                        // 1-4级区域按原来逻辑处理
                        else if (rank <= 4) {
                            // 20%概率为回声区域
                            if (seededRandom() < 0.2) {
                                type = 'echo';
                            }
                        }
                        
                        return {
                            pathId,              // 路径ID
                            rank,                // 区域等级 (1-13)
                            type,                // 区域类型
                            wonderData,          // 奇观数据（如果是奇观）
                            combatData,          // 战争区域数据（如果是战争区域）
                            status: 'unexplored',// 状态: unexplored, explored, occupied
                            occupyCard: null,    // 占领的卡牌
                            points: 0            // 每回合提供的分数
                        };
                    });
                    
                    // 渲染区域
                    const regionContainer = document.getElementById(`${pathId}-regions`);
                    regionContainer.innerHTML = '';
                    
                    // 倒序渲染区域（从13到1），显示最高等级(13)在顶部
                    for (let i = 12; i >= 0; i--) {
                        const region = gameState.regions[pathId][i];
                        const regionElement = document.createElement('div');
                        
                        // 使用与手牌一致的尺寸
                        regionElement.className = 'rounded-md w-16 h-24 md:w-20 md:h-30 border shadow-md flex flex-col items-center justify-center cursor-pointer relative';
                        
                        // 根据区域状态调整样式
                        if (region.status === 'unexplored') {
                            regionElement.classList.add('bg-gray-400', 'dark:bg-gray-700');
                        } else if (region.status === 'explored') {
                            regionElement.classList.add('bg-white', 'dark:bg-gray-600');
                        } else if (region.status === 'occupied') {
                            regionElement.classList.add('bg-blue-100', 'dark:bg-blue-800');
                        }
                        
                        // 如果是回声区域，添加特殊样式
                        if (region.type === 'echo' && region.status !== 'occupied') {
                            regionElement.classList.add('bg-green-200', 'dark:bg-green-800');
                        }
                        
                        // 如果是奇观区域，添加特殊样式
                        if (region.type === 'wonder' && region.wonderData) {
                            const tierClass = `wonder-${region.wonderData.tier}`;
                            regionElement.classList.add(tierClass);
                        }
                        
                        regionElement.dataset.path = pathId;
                        regionElement.dataset.rank = i + 1;
                        regionElement.dataset.type = region.type;
                        
                        // 区域等级显示
                        const rankElement = document.createElement('div');
                        rankElement.className = 'text-sm font-bold absolute top-1 left-1';
                        rankElement.textContent = i + 1; // 直接显示数字1-13
                        regionElement.appendChild(rankElement);
                        
                        // 状态标识
                        const statusIndicator = document.createElement('div');
                        statusIndicator.className = 'absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-xs font-bold';
                        
                        if (region.status === 'unexplored') {
                            // 未探索的奇观显示为???
                            if (region.type === 'wonder' || region.type === 'combat') {
                                statusIndicator.textContent = '???';
                                statusIndicator.className += ' text-white';
                            } else {
                                statusIndicator.textContent = '未探索';
                                statusIndicator.className += ' text-gray-100 dark:text-gray-300';
                            }
                        } else if (region.status === 'explored') {
                            statusIndicator.textContent = '可占领';
                            statusIndicator.className += ' text-green-600 dark:text-green-400';
                        }
                        
                        // 只有在非占领状态下才添加状态指示器
                        if (region.status !== 'occupied') {
                            regionElement.appendChild(statusIndicator);
                        }
                        
                        // 区域类型指示器（回声区域）
                        if (region.type === 'echo' && region.status !== 'occupied') {
                            const typeIndicator = document.createElement('div');
                            typeIndicator.className = 'absolute top-1 right-1 w-2 h-2 rounded-full bg-green-400 dark:bg-green-300';
                            regionElement.appendChild(typeIndicator);
                        }
                        
                        // 添加点击事件
                        regionElement.addEventListener('click', () => handleRegionClick(pathId, i));
                        
                        regionContainer.appendChild(regionElement);
                    }
                }
            }

            // 尝试使用当前选中的手牌解除战争区域
            function attemptResolveCombatWithCards(pathId, index) {
                const region = gameState.regions[pathId][index];

                if (region.type !== 'combat' || region.status !== 'explored' || !region.combatData) {
                    showMessage("这不是一个可以解除的战争区域");
                    resetSelectionState();
                    return;
                }

                if (gameState.selectedCards.length === 0) {
                    showMessage('请先选择要用于解除战争的手牌');
                    return;
                }

                const selectedCards = gameState.selectedCards.map(idx => gameState.hand[idx]);
                const requirement = region.combatData.requirement;

                // Retrieve the check function using the stored name
                const checkFunction = COMBAT_CHECK_FUNCTIONS[requirement.checkFnName];

                if (typeof checkFunction !== 'function') {
                    console.error(`Error: Combat check function '${requirement.checkFnName}' not found or not a function for region ${pathId}-${index}`);
                    showMessage(`解除失败：内部错误，无法找到战争解除条件`);
                    addLogEntry(`解除失败: ${PATH_NAMES[pathId]} ${region.rank}级「${region.combatData.name}」，内部条件错误`);
                    resetSelectionState();
                    return;
                }


                if (hasPattern(selectedCards, checkFunction)) { // Pass the retrieved function
                    resolveCombatSuccessfully(pathId, index, gameState.selectedCards);
                } else {
                    showMessage(`解除失败：选中的手牌不满足条件 "${requirement.display}"`);
                    addLogEntry(`解除失败: ${PATH_NAMES[pathId]} ${region.rank}级「${region.combatData.name}」，选中的牌不满足条件`);
                    resetSelectionState();
                }

                updateCornerInfo();
                addToHistory(saveGameState());
            }
            
            // 检查区域是否可以被探索（必须相邻于已探索或已占领区域）
            function canExploreRegion(pathId, index) {
                // 获取同一路径中rank值低1的区域
                const lowerRankIndex = index - 1;
                
                // 如果是最低等级(1)，总是可以探索
                if (index === 0) return true;
                
                // 检查低一级区域是否已被探索或占领
                if (lowerRankIndex >= 0) {
                    const lowerRegion = gameState.regions[pathId][lowerRankIndex];
                    if (lowerRegion.status === 'explored' || lowerRegion.status === 'occupied') {
                        return true;
                    }
                }
                
                return false;
            }

            // 检查是否有战争区域阻碍更高级区域的探索
            function hasBlockingCombatZone(pathId, targetIndex) {
                // 获取目标区域的等级
                const targetRank = targetIndex + 1;
                
                // 检查该路径上是否有战争区域阻塞了更高级区域的探索
                for (let i = 0; i < targetIndex; i++) {
                    const region = gameState.regions[pathId][i];
                    // 如果有已探索但未解除的战争区域且仍在阻塞中
                    if (region.status === 'explored' && 
                        region.type === 'combat' && 
                        region.combatData && 
                        region.combatData.blocking) {
                        return true;
                    }
                }
                return false;
            }
            

            
            // 在格子上显示临时错误提示
            function showErrorOnRegion(regionElement, message) {
                // 创建错误提示元素
                const errorTooltip = document.createElement('div');
                errorTooltip.className = 'absolute inset-0 bg-red-500 bg-opacity-80 flex items-center justify-center rounded-md z-10';
                errorTooltip.style.animation = 'fadeIn 0.2s ease-out';
                
                const textElement = document.createElement('div');
                textElement.className = 'text-white text-xs font-bold px-1 text-center';
                textElement.textContent = message;
                
                errorTooltip.appendChild(textElement);
                regionElement.appendChild(errorTooltip);
                
                // 2秒后自动移除
                setTimeout(() => {
                    errorTooltip.style.animation = 'fadeOut 0.5s ease-out';
                    setTimeout(() => {
                        if (regionElement.contains(errorTooltip)) {
                            regionElement.removeChild(errorTooltip);
                        }
                    }, 500);
                }, 2000);
            }
            
            function handleRegionClick(pathId, index) {
                // 获取区域元素
                const regionContainer = document.getElementById(`${pathId}-regions`);
                const displayIndex = 12 - index; // 倒序渲染的索引
                const regionElement = regionContainer.children[displayIndex];

                const region = gameState.regions[pathId][index];

                // --- 修改开始 ---
                // 如果是已探索的战争区域
                if (region.status === 'explored' && region.type === 'combat' && region.combatData) {
                    // 如果已经选择了手牌 (无论是单选还是多选)
                    if (gameState.selectedCards.length > 0) {
                        // 直接尝试使用选中的手牌解除战争
                        attemptResolveCombatWithCards(pathId, index);
                    } else {
                        // 如果没有选择手牌，显示解除战争弹窗
                        showResolveCombatModal(pathId, index);
                    }
                    // 处理完战争区域点击后，无论如何都返回，不继续执行下面的探索/占领逻辑
                    return;
                }
                // --- 修改结束 ---


                // 以下是原有的非战争区域处理逻辑

                // 检查是否选择了手牌
                if (gameState.selectedCards.length === 0) {
                    showErrorOnRegion(regionElement, t('selectCard'));
                    showMessage(t('selectCard'));
                    return;
                }

                // 以下逻辑只允许单选进行探索或占领
                if (gameState.selectedCards.length > 1) {
                    // 如果不是战争区域，多选了卡牌，视为无效操作，提示用户
                    showErrorOnRegion(regionElement, "此操作只能使用一张牌");
                    showMessage("探索或占领操作只能使用一张牌，请只选择一张");
                    resetSelectionState(); // 多选在这种情况下是无效的，直接重置选择
                    return;
                }


                // 以下是单选卡牌的探索/占领逻辑
                const cardIndex = gameState.selectedCards[0]; // 只取第一个选中的卡牌
                const card = gameState.hand[cardIndex];
                const cardRank = RANK_VALUES[card.rank];


                // 自动判断操作类型
                if (region.status === 'unexplored') {
                    // 探索操作

                    // 计算有效点数（黑桃翻倍）
                    let effectiveRank = cardRank;
                    if (card.suit === 'spade') {
                        effectiveRank = cardRank * 2;
                    }

                    // 检查卡牌点数是否足够
                    if (effectiveRank < region.rank) {
                        showErrorOnRegion(regionElement, t('notEnoughRank'));
                        showMessage(t('notEnoughRank'));
                        resetSelectionState(); // 探索失败，重置选择
                        return;
                    }

                    // 检查是否可以探索该区域（必须相邻于已探索区域）
                    if (!canExploreRegion(pathId, index)) {
                        showErrorOnRegion(regionElement, '只能探索相邻格子');
                        showMessage('只能探索已探索区域相邻的格子');
                        resetSelectionState(); // 探索失败，重置选择
                        return;
                    }

                    // 检查是否被战争区域阻塞了更高级区域的探索
                    if (hasBlockingCombatZone(pathId, index)) {
                        showErrorOnRegion(regionElement, '必须先解除战争区域');
                        showMessage('有战争区域阻碍了进一步探索，请先解除战争');
                        resetSelectionState(); // 探索失败，重置选择
                        return;
                    }

                    // 执行探索行动
                    exploreRegion(pathId, index); // exploreRegion 内部会处理移除卡牌、更新状态、日志、重置选择、保存历史

                }
                else if (region.status === 'explored') {
                    // 占领操作 (非战争区域)

                    // 检查是否是遗忘区域，遗忘区域不能正常占领
                    /*
                    if (region.type === 'forgotten') {
                        showErrorOnRegion(regionElement, '遗忘区域无法占领');
                        showMessage('遗忘区域无法占领');
                        resetSelectionState();
                        return;
                    }*/

                    // 占领区域
                    occupyRegion(pathId, index); // occupyRegion 内部会处理移除卡牌、更新状态、日志、重置选择、保存历史

                }
                else if (region.status === 'occupied') {
                    // 已被占领
                    showErrorOnRegion(regionElement, t('alreadyOccupied'));
                    showMessage(t('alreadyOccupied'));
                    resetSelectionState(); // 已占领区域点击是无效操作，重置选择
                }
            }
            
            // 显示解除战争区域弹窗
            function showResolveCombatModal(pathId, index) {
                const region = gameState.regions[pathId][index];

                // 如果不是战争区域或不是已探索状态，直接返回
                if (region.type !== 'combat' || region.status !== 'explored' || !region.combatData) {
                    return;
                }

                // 创建弹窗元素 (modalOverlay, modalContent 等) ... 保持不变
                // 创建弹窗元素
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                
                const modalContent = document.createElement('div');
                modalContent.className = 'bg-white dark:bg-gray-800 p-5 rounded-lg shadow-lg max-w-md w-full mx-4';
                
                // 战争区域信息
                const combatTier = region.combatData.tier;
                const requirement = region.combatData.requirement;
                const effect = region.combatData.effect;

                // ... 战争区域信息 (title, descriptionContainer) ... 保持不变
                // 标题
                const title = document.createElement('h3');
                title.className = `text-xl font-bold mb-3 text-center ${combatTier === 'orange' ? 'text-orange-500' : combatTier === 'purple' ? 'text-purple-500' : 'text-blue-500'}`;
                title.textContent = `${region.combatData.name} (${PATH_NAMES[pathId]} ${region.rank}级)`;
                
                // 战争区域描述
                const descriptionContainer = document.createElement('div');
                descriptionContainer.className = 'mb-4 p-3 bg-gray-100 dark:bg-gray-700 rounded';
                
                const requirementTitle = document.createElement('div');
                requirementTitle.className = 'font-bold mb-1';
                requirementTitle.textContent = '解除条件:';
                
                const requirementDesc = document.createElement('div');
                requirementDesc.className = 'mb-2 text-sm';
                requirementDesc.textContent = requirement.display;
                
                const effectTitle = document.createElement('div');
                effectTitle.className = 'font-bold mb-1';
                effectTitle.textContent = '未解除效果:';
                
                const effectDesc = document.createElement('div');
                effectDesc.className = 'text-sm text-red-500 dark:text-red-400';
                
                // 替换效果描述中的参数
                let effectDescription = effect.description;
                if (effect.type === 'income_loss') {
                    effectDescription = effectDescription.replace('{points}', effect.points);
                } else {
                    effectDescription = effectDescription.replace('{count}', effect.severity);
                }
                
                effectDesc.textContent = effectDescription;
                
                descriptionContainer.appendChild(requirementTitle);
                descriptionContainer.appendChild(requirementDesc);
                descriptionContainer.appendChild(effectTitle);
                descriptionContainer.appendChild(effectDesc);

                // 选择区域容器
                const selectionContainer = document.createElement('div');
                selectionContainer.className = 'mb-4';

                const selectionTitle = document.createElement('div');
                selectionTitle.className = 'font-bold mb-2';
                selectionTitle.textContent = '选择解除方式:';

                // 使用多选手牌解除的选项
                const resolveButton = document.createElement('button');
                resolveButton.className = 'bg-primary hover:bg-indigo-700 text-white px-4 py-2 rounded-lg w-full mb-2';
                resolveButton.textContent = `使用手牌解除 (${region.combatData.requirement.display})`; // 显示具体条件
                resolveButton.addEventListener('click', () => {
                    // 关闭弹窗
                    document.body.removeChild(modalOverlay);
                    // 调用新的统一尝试解除函数
                    attemptResolveCombatWithCards(pathId, index);
                    // 注意：attemptResolveCombatWithCards 会处理成功/失败、日志、重置选择、更新UI和保存历史
                });

                // 接受负面效果并结束回合的选项
                const acceptEffectButton = document.createElement('button');
                acceptEffectButton.className = 'bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg w-full mb-4';
                acceptEffectButton.textContent = '接受效果并结束回合';
                acceptEffectButton.addEventListener('click', () => {
                    // 关闭弹窗
                    document.body.removeChild(modalOverlay);
                    // 玩家主动选择接受惩罚，立即结束回合。endTurn 函数会自动检测到这个未解除的战争区域并应用惩罚。
                    endTurn();
                    // endTurn 函数会处理惩罚、区域状态、日志、抽牌、更新UI和保存历史
                });


                selectionContainer.appendChild(selectionTitle);
                selectionContainer.appendChild(resolveButton);
                selectionContainer.appendChild(acceptEffectButton);

                // 取消按钮
                const cancelButton = document.createElement('button');
                cancelButton.className = 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 px-4 py-2 rounded-lg w-full';
                cancelButton.textContent = '取消';
                cancelButton.addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    // 取消弹窗不进行任何游戏操作，不影响当前选择状态
                });

                
                // 组装弹窗
                modalContent.appendChild(title);
                modalContent.appendChild(descriptionContainer);
                modalContent.appendChild(selectionContainer);
                modalContent.appendChild(cancelButton);
                
                modalOverlay.appendChild(modalContent);
                document.body.appendChild(modalOverlay);
            }
            
            function resolveCombatSuccessfully(pathId, index, usedCardIndices) { // <-- 确保这里有 usedCardIndices 参数
                const region = gameState.regions[pathId][index];

                // 将战争区域转变为回声区域
                region.type = 'echo';
                region.combatData.blocking = false;  // 解除阻塞
                region.combatData = null; // 解除后清除战争数据
                region.wonderData = null; // 确保类型是回声，不是奇观
                region.wonderEffect = null; // 清除可能残留的奇观效果

                // 将用于解除的卡牌加入弃牌堆并从手牌中移除
                // 按照索引从大到小排序，以便 splice 操作不会影响后续索引
                const indicesToRemove = [...usedCardIndices].sort((a, b) => b - a); // <-- 这里现在使用 usedCardIndices

                 for (const cardIndex of indicesToRemove) {
                    const card = gameState.hand[cardIndex]; // 在 splice 移除之前获取卡牌

                    // 将卡牌加入弃牌堆
                    gameState.discardPile.push(card);

                    // 从手牌中移除
                    gameState.hand[cardIndex] = -1;
                }

                gameState.hand = gameState.hand.filter(card => card !== -1); // 过滤掉 -1，移除空位
                // 更新弃牌堆计数
                updateDiscardCount();

                // 更新区域显示 (更新解除后的区域)
                updateRegionDisplay(pathId, index);

                // 记录操作 (如果日志没有在 attemptResolveCombatWithCards 中详细记录的话，可以在这里补充)
                // addLogEntry(`解除战争成功: ${PATH_NAMES[pathId]} ${region.rank}级`); // 示例精简日志

                // 显示成功消息
                showMessage(`成功解除战争区域！区域变为回声区域`);

                // 重置选择状态 (清除 gameState.selectedCards)
                resetSelectionState();

                // 重新渲染手牌 (因为手牌数量变化了)
                renderHand();

                // 更新右下角信息栏 (手牌/弃牌数量变化)
                updateCornerInfo();

                // 更新所有花色收获奇观的得分 (因为弃牌可能影响花色数量)
                updateAllSuitBonusWonders();

                // 保存游戏状态到历史记录
                addToHistory(saveGameState());
            }
            
            // 处理接受战争区域负面效果并解除战争区域
            function resolveCombatWithPenalty(pathId, index) {
                const region = gameState.regions[pathId][index];
                // Preserve combat data for logging before clearing it
                const originalCombatData = region.combatData;
                const effect = originalCombatData.effect;

                // 应用负面效果 (这可能会改变其他区域的状态，对于 exploration_loss 可能会将此区域本身也改回 unexplored)
                applyNegativeEffect(pathId, index, effect);


                // --- 最终确定触发此惩罚的战争区域 (index) 的状态 ---
                region.type = 'forgotten'; // 始终变为遗忘类型
                region.combatData = null;   // 清除战争数据
                region.wonderData = null;   // 清除奇观数据
                region.wonderEffect = null; // 清除奇观效果
                region.points = 0;          // 遗忘区域得分0

                // 根据效果类型设置最终状态
                if (effect.type === 'exploration_loss') {
                    // 如果是模因入侵，最终状态是未探索
                    region.status = 'unexplored';
                } else {
                    // 其他效果，最终状态是已探索
                    region.status = 'explored';
                }

                region.blocking = false; // 始终解除对后续格子的阻碍

                // 更新区域显示 (更新触发区域)
                updateRegionDisplay(pathId, index);

                // 记录到游戏日志
                let effectDescForLog = effect.description.replace('{count}', effect.severity).replace('{points}', effect.points);
                // Use originalCombatData for name in log if available
                addLogEntry(`接受战争效果: ${PATH_NAMES[pathId]} ${region.rank}级「${originalCombatData ? originalCombatData.name : '战争区域'}」，区域变为遗忘（${region.status === 'unexplored' ? '未探索' : '已探索'}），受到负面效果：${effectDescForLog}`);

                // Note: updateAllSuitBonusWonders is handled by effect functions if needed or at the end of endTurn.
            }
            
            // 应用战争区域的负面效果
            function applyNegativeEffect(pathId, index, effect) {
                const severity = effect.severity; // 效果严重程度（数量）

                switch(effect.type) {
                    case 'occupy_loss':
                        removeHighestScoringOccupations(pathId, severity, false);
                        break;

                    case 'wonder_loss':
                        removeHighestScoringOccupations(pathId, severity, true);
                        break;

                    case 'income_loss':
                        // 根据严重程度确定掠夺的倍率
                        let pillageMultiplier;
                        if (severity === 3) pillageMultiplier = 10; // 橙级
                        else if (severity === 2) pillageMultiplier = 5; // 紫级
                        else pillageMultiplier = 3; // 蓝级 (severity 1)

                        // 记录掠夺惩罚倍率
                        recordPillagePenalty(pathId, pillageMultiplier);
                        // 实际扣分在 endTurn 中结算
                        break;

                    case 'exploration_loss':
                        revertTopExploredRegions(pathId, severity);
                        break;

                    case 'area_loss':
                        convertToForgottenRegions(pathId, index, severity);
                        break;
                }
            }
            
            // 移除路径上得分最高的N个占领区域
           
            // 移除路径上得分最高的N个占领区域（不包括奇观，或只包括奇观）
            function removeHighestScoringOccupations(pathId, count, wondersOnly) {
                // 获取该路径的所有已占领区域 (根据 wondersOnly 过滤)
                const occupiedRegions = [];
                for (let i = 0; i < gameState.regions[pathId].length; i++) {
                    const region = gameState.regions[pathId][i];
                    if (region.status === 'occupied') {
                        if ((wondersOnly && region.type === 'wonder') ||
                            (!wondersOnly && region.type !== 'wonder' && region.type !== 'forgotten')) { // 遗忘区域也不能被普通沦陷移除
                            occupiedRegions.push({index: i, region, points: region.points});
                        }
                    }
                }

                // 按得分从高到低排序
                occupiedRegions.sort((a, b) => b.points - a.points);

                // 确定实际移除数量
                const actualCount = Math.min(count, occupiedRegions.length);
                const removedRegions = [];

                // 移除区域并加入弃牌堆
                for (let i = 0; i < actualCount; i++) {
                    const { index, region } = occupiedRegions[i];

                    let regionInfo = `${PATH_NAMES[pathId]} ${region.rank}`;
                    if (region.type === 'wonder' && region.wonderData) regionInfo += ` 奇观「${region.wonderData.name}」`;
                    removedRegions.push(`${regionInfo} (${region.points}分/回合)`);

                    if (region.occupyCard) {
                        gameState.discardPile.push(region.occupyCard);
                    }

                    // 重置区域状态为已探索
                    region.status = 'explored'; // 变为可重新占领
                    region.occupyCard = null;
                    region.points = 0;

                    if (region.type === 'wonder' && region.wonderEffect) {
                        region.wonderEffect = null; // 移除奇观效果
                    }

                    updateRegionDisplay(pathId, index);
                }

                // --- 新增：如果移除数量不足，应用罚分 ---
                const deficit = count - actualCount;
                if (deficit > 0) {
                    const penalty = deficit * 100;
                    gameState.score -= penalty;
                    scoreDisplay.textContent = gameState.score; // 更新UI得分
                    updateCornerInfo(); // 更新所有信息
                    addLogEntry(`「${wondersOnly ? '奇迹沦陷' : '沦陷'}」效果: 移除了${actualCount}个占领区域，缺少${deficit}个，每缺少一个损失100分，总损失${penalty}分`);
                }
                // --- 新增结束 ---

                // 更新弃牌堆计数
                updateDiscardCount();

                // 记录到游戏日志
                if (removedRegions.length > 0) {
                    addLogEntry(`「${wondersOnly ? '奇迹沦陷' : '沦陷'}」效果: ${removedRegions.join(', ')} 被移除`);
                } else if (deficit === 0) { // 如果实际移除为0但不需要罚分，说明没有满足条件的区域
                    addLogEntry(`无法执行「${wondersOnly ? '奇迹沦陷' : '沦陷'}」效果：${PATH_NAMES[pathId]}上没有${wondersOnly ? '奇观' : '普通'}占领区域`);
                }


                // 更新所有花色收获奇观的得分 (因为占领卡被移除了)
                updateAllSuitBonusWonders();
            }

            // 记录掠夺惩罚的倍率，将在回合结束时结算
            function recordPillagePenalty(pathId, multiplier) {
                if (!gameState.pillagePenalties) {
                    gameState.pillagePenalties = {};
                }
                if (!gameState.pillagePenalties[pathId]) {
                    gameState.pillagePenalties[pathId] = [];
                }
                // 添加当前倍率到该路径的倍率列表
                gameState.pillagePenalties[pathId].push(multiplier);

                // 记录日志，提示惩罚已触发，但未结算
                addLogEntry(`「掠夺」效果触发: ${PATH_NAMES[pathId]}路径，本回合将遭受 ${multiplier}x 倍率收入损失`);
            }
            
            // 应用路径收入损失
            /*
            function applyPathIncomeLoss(pathId, points) {
                // 记录该路径被减少的收入
                if (!gameState.incomeLoss) {
                    gameState.incomeLoss = {};
                }
                
                gameState.incomeLoss[pathId] = (gameState.incomeLoss[pathId] || 0) + points;
                
                // 记录到游戏日志
                addLogEntry(`「掠夺」效果: ${PATH_NAMES[pathId]}路径本回合减少${points}点收入`);
            }*/
           // 将路径上最高级的N个已探索/占领区域恢复为未探索状态
            // (可以包括触发效果的战争区域本身)
            function revertTopExploredRegions(pathId, count) { // Simplified: No need to pass triggering index here anymore

                // 获取该路径所有 已探索 或 已占领 的区域
                const potentialRegionsToRevert = [];
                for (let i = 0; i < gameState.regions[pathId].length; i++) {
                    const region = gameState.regions[pathId][i];
                    if (region.status === 'explored' || region.status === 'occupied') {
                        potentialRegionsToRevert.push({index: i, rank: region.rank, occupied: region.status === 'occupied'});
                    }
                }

                // 如果没有可还原区域
                if (potentialRegionsToRevert.length === 0) {
                    // --- 新增：如果数量不够，应用罚分 ---
                    const deficit = count;
                    if (deficit > 0) {
                        const penalty = deficit * 100;
                        gameState.score -= penalty;
                        scoreDisplay.textContent = gameState.score;
                        updateCornerInfo();
                        addLogEntry(`「模因入侵」效果: ${PATH_NAMES[pathId]}上没有可还原区域，缺少${deficit}个，每缺少一个损失100分，总损失${penalty}分`);
                    } else {
                        // Log if count is 0, but no regions found
                        addLogEntry(`无法执行「模因入侵」效果：${PATH_NAMES[pathId]}上没有已探索/占领区域`);
                    }
                    // --- 新增结束 ---
                    return;
                }

                // 按等级从高到低排序
                potentialRegionsToRevert.sort((a, b) => b.rank - a.rank);

                // 确定实际还原数量（最多count个）
                const actualCount = Math.min(count, potentialRegionsToRevert.length);
                const revertedRegionsInfo = []; // 用于日志记录

                // 对前 actualCount 个区域进行处理
                for (let i = 0; i < actualCount; i++) {
                    const { index, rank, occupied } = potentialRegionsToRevert[i];
                    const region = gameState.regions[pathId][index]; // 获取区域当前状态

                    // 如果这个区域在处理过程中状态变了 (不应该发生但保险)
                    if (region.status === 'unexplored') continue;

                    // 记录被还原的区域信息
                    let regionDescription = `${PATH_NAMES[pathId]} ${rank}`;
                    if (region.type === 'wonder' && region.wonderData) regionDescription += ` 奇观「${region.wonderData.name}」`;
                    else if (region.type === 'combat' && region.combatData) regionDescription += ` 战争「${region.combatData.name}」`; // 模因入侵会影响战争区域本身
                    else if (region.type === 'echo') regionDescription += ` (回声区域)`;
                    else if (region.type === 'forgotten') regionDescription += ` (遗忘区域)`; // 模因入侵可能影响其他遗忘区域

                    revertedRegionsInfo.push(regionDescription);


                    // 如果区域是占领状态，将卡牌弃掉
                    if (region.status === 'occupied') {
                        if (region.occupyCard) {
                            gameState.discardPile.push(region.occupyCard);
                            region.occupyCard = null;
                        }
                        region.points = 0; // 占领得分归零
                        // 如果是占领的奇观，移除效果
                        if (region.type === 'wonder' && region.wonderEffect) {
                            region.wonderEffect = null;
                        }
                    }


                    // *** 关键修改：设置状态为未探索，如果是原战争区域，同时改为遗忘类型 ***
                    region.status = 'unexplored';
                    // 如果被还原的区域是战斗区域，它现在变为遗忘区域
                    if (region.type === 'combat') { // 注意：这里判断 type === 'combat' 是指原始类型
                        // 如果触发区域通过此效果被还原，则将其类型改为 forgotten
                        // 但这个逻辑应该在 resolveCombatWithPenalty 中处理更好，保证触发区域的最终状态
                        // 这里的 revertTopExploredRegions 应该只负责将区域状态改回 unexplored 和弃牌
                        // type 变为 forgotten 的逻辑由 resolveCombatWithPenalty 统一处理
                    }


                    // 更新区域显示
                    updateRegionDisplay(pathId, index);
                }

                // --- 新增：如果实际还原数量不足，应用罚分 ---
                const deficit = count - actualCount;
                if (deficit > 0) {
                    const penalty = deficit * 100;
                    gameState.score -= penalty;
                    scoreDisplay.textContent = gameState.score;
                    updateCornerInfo();
                    addLogEntry(`「模因入侵」效果: 移除了${actualCount}个可还原区域，缺少${deficit}个，每缺少一个损失100分，总损失${penalty}分`);
                }
                // --- 新增结束 ---


                // 更新弃牌堆计数 (如果实际有弃牌的话)
                if (actualCount > 0 && revertedRegionsInfo.length > 0) {
                    updateDiscardCount();
                    // 更新花色得分 (如果弃掉了占领卡)
                    updateAllSuitBonusWonders();
                }


                // 记录到游戏日志
                if (revertedRegionsInfo.length > 0) {
                    addLogEntry(`「模因入侵」效果: ${revertedRegionsInfo.join(', ')} 被重置为未探索状态`);
                }
                // 如果 actualCount == 0 且 deficit == 0, 已经在上面 log 了 "无法执行"

            }
            
            // 将指定区域上方的N个格子转换为遗忘区域
            function convertToForgottenRegions(pathId, startIndex, count) {
                // 获取可能被影响的区域
                const regions = [];
                
                // 只获取比startIndex等级更高的区域
                for (let i = startIndex + 1; i < gameState.regions[pathId].length; i++) {
                    regions.push(i);
                }
                
                // 如果没有可转换的区域，直接返回
                if (regions.length === 0) {
                    addLogEntry(`无法执行「未来破坏」效果：${PATH_NAMES[pathId]} ${startIndex + 1}级以上没有区域`);
                    return;
                }
                
                // 确定要转换的数量
                const actualCount = Math.min(count, regions.length);
                const convertedRegions = [];
                
                // 从startIndex往上转换actualCount个区域
                for (let i = 0; i < actualCount; i++) {
                    const index = regions[i];
                    const region = gameState.regions[pathId][index];
                    
                    // 记录被转换的区域信息
                    convertedRegions.push(`${PATH_NAMES[pathId]} ${region.rank}`);
                    
                    // 如果区域被占领，先将卡牌弃掉
                    if (region.status === 'occupied' && region.occupyCard) {
                        gameState.discardPile.push(region.occupyCard);
                        region.occupyCard = null;
                    }
                    
                    // 转换为遗忘区域
                    region.type = 'forgotten';
                    region.wonderData = null;
                    region.combatData = null;
                    region.wonderEffect = null;
                    region.points = 0;
                    region.status = 'explored'; // 变为已探索状态
                    
                    // 更新区域显示
                    updateRegionDisplay(pathId, index);
                }
                
                // 更新弃牌堆计数
                updateDiscardCount();
                
                // 记录到游戏日志
                addLogEntry(`「未来破坏」效果: ${convertedRegions.join(', ')} 被转换为遗忘区域`);
                
                // 更新所有花色收获奇观的得分
                updateAllSuitBonusWonders();
            }
            
            // 探索区域
            function exploreRegion(pathId, index, cardIndex) {
                // 获取选择的卡牌索引（使用selectedCards数组第一个元素）
                const selectedCardIndex = gameState.selectedCards[0];
                // 获取选择的卡牌和区域
                const card = gameState.hand[selectedCardIndex];
                const region = gameState.regions[pathId][index];
                const cardRank = RANK_VALUES[card.rank];
                
                // 计算探索得分
                let points = REGION_TYPES[region.type].explorePoints;
                let bonusInfo = '';
                
                // 黑桃探索效果：rank值翻倍
                // 黑桃的卡牌在探索时，相当于点数翻倍
                let effectiveRank = cardRank;
                if (card.suit === 'spade') {
                    effectiveRank = cardRank * 2;
                    bonusInfo = `(${t('spadeBonus')}: rank ${cardRank}→${effectiveRank})`;
                }
                
                // 如果有效rank值小于区域等级，无法探索
                if (effectiveRank < region.rank) {
                    showMessage(t('notEnoughRank'));
                    return;
                }
                
                // 更新分数
                gameState.score += points;
                scoreDisplay.textContent = gameState.score;
                
                // 更新右下角信息栏
                updateCornerInfo();
                
                // 更新区域状态
                region.status = 'explored';
                
                // 更新区域显示
                updateRegionDisplay(pathId, index);
                
                // 从手牌中移除卡牌，加入弃牌堆
                gameState.discardPile.push(card);
                gameState.hand.splice(selectedCardIndex, 1);
                
                // 更新弃牌堆计数
                updateDiscardCount();
                
                // 重新渲染手牌
                renderHand();
                
                // 记录操作
                addLogEntry(`${t('explore')}: ${PATH_NAMES[pathId]} ${region.rank} (${card.rank}${SUIT_SYMBOLS[card.suit]}) +${points}分 ${bonusInfo}`);
                
                // 显示消息
                showMessage(t('exploreDone', {points: points}));
                
                // 重置选择状态
                resetSelectionState();
                
                // 保存游戏状态到历史记录
                addToHistory(saveGameState());
            }
            
            // 处理奇观占领效果
            function processWonderEffects(region, pathId) {
                const wonderTier = region.wonderData.tier;
                const effect = region.wonderData.effect;
                const tierData = WONDER_TIERS[wonderTier];
                const multiplier = tierData.effectMultiplier;
                
                let points = 0;
                let effectDescription = '';
                let immediatePoints = tierData.baseScore;
                
                // 处理不同的奇观效果类型
                switch(effect.type) {
                    case 'draw':
                        // 抽卡效果：每回合额外抽牌
                        // 这个效果会在endTurn中处理
                        region.wonderEffect = {
                            type: 'draw',
                            value: multiplier
                        };
                        effectDescription = `每回合多抽${multiplier}张`;
                        points = 0; // 这个效果不提供直接分数
                        break;
                        
                    case 'population':
                        // 人口效果：增加手牌上限
                        region.wonderEffect = {
                            type: 'population',
                            value: multiplier // 橙色+3, 紫色+2, 蓝色+1
                        };
                        effectDescription = `手牌上限+${multiplier}`;
                        points = 0; // 这个效果不提供直接分数
                        break;
                        
                    case 'score':
                        // 得分效果：每回合额外得分
                        points = 10 * multiplier; // 橙色+30/t, 紫色+20/t, 蓝色+10/t
                        effectDescription = `每回合+${points}分`;
                        break;
                        
                    case 'explore':
                        // 探索效果：立即探索该路径上的额外格子
                        const extraExplores = multiplier;
                        
                        // 找到当前已探索的最高等级区域
                        let highestExploredRank = 0;
                        for (const r of gameState.regions[pathId]) {
                            if (r.status !== 'unexplored' && r.rank > highestExploredRank) {
                                highestExploredRank = r.rank;
                            }
                        }
                        
                        // 探索额外的格子
                        let exploredCount = 0;
                        for (let i = 0; i < gameState.regions[pathId].length && exploredCount < extraExplores; i++) {
                            const r = gameState.regions[pathId][i];
                            if (r.rank > highestExploredRank && r.status === 'unexplored') {
                                r.status = 'explored';
                                updateRegionDisplay(pathId, i);
                                exploredCount++;
                            }
                        }
                        
                        effectDescription = `额外探索了${exploredCount}格`;
                        break;
                        
                    case 'heart_bonus':
                    case 'spade_bonus':
                    case 'diamond_bonus':
                    case 'club_bonus':
                        // 花色收获效果：根据奇观等级，对该路径上的对应花色每回合计分
                        const suit = effect.type.split('_')[0]; // 'heart', 'spade', 'diamond', 'club'
                        
                        // 根据奇观等级设置不同的倍率
                        let bonusMultiplier;
                        if (wonderTier === 'orange') {
                            bonusMultiplier = 6; // 橙色奇观：6×n²
                        } else if (wonderTier === 'purple') {
                            bonusMultiplier = 4; // 紫色奇观：4×n²
                        } else {
                            bonusMultiplier = 3; // 蓝色奇观：3×n²
                        }
                        
                        region.wonderEffect = {
                            type: 'suit_bonus',
                            suit: suit,
                            pathId: pathId,
                            formula: 'squared',
                            multiplier: bonusMultiplier // 保存倍率
                        };
                        
                        // 计算当前路径上已有的该花色牌数
                        let suitCount = 0;
                        for (const r of gameState.regions[pathId]) {
                            if (r.status === 'occupied' && r.occupyCard && r.occupyCard.suit === suit) {
                                suitCount++;
                            }
                        }
                        
                        // 使用新公式：bonusMultiplier × (花色数量)²
                        points = bonusMultiplier * (suitCount * suitCount);
                        effectDescription = `${PATH_NAMES[pathId]}路径上${SUIT_SYMBOLS[suit]}：${bonusMultiplier}×数量²分/回合`;
                        break;
                }
                
                // 立即增加分数
                gameState.score += immediatePoints;
                scoreDisplay.textContent = gameState.score;
                
                return {
                    points,
                    effectDescription,
                    immediatePoints
                };
            }
            
            // 占领区域
            // 占领区域
        function occupyRegion(pathId, index) {
            // 获取选择的卡牌索引（使用selectedCards数组第一个元素）
            const selectedCardIndex = gameState.selectedCards[0];
            // 获取选择的卡牌和区域
            const card = gameState.hand[selectedCardIndex];
            const region = gameState.regions[pathId][index];
            const cardRank = RANK_VALUES[card.rank];

            // 检查是否是奇观区域，需要特殊处理
            if (region.type === 'wonder' && region.wonderData) {
                // ... (奇观占领逻辑，保持不变) ...
                // 检查卡牌是否满足奇观占领条件
                if (!cardMeetsWonderCondition(card, region.wonderData)) {
                    // ... (显示错误消息，保持不变) ...
                    return; // 不满足条件，停止执行
                }

                // 处理奇观效果
                const wonderEffectResult = processWonderEffects(region, pathId);

                // 更新区域状态
                region.status = 'occupied';
                region.occupyCard = card;
                region.points = wonderEffectResult.points; // 每回合得分 (奇观效果决定)

                // 更新区域显示
                updateRegionDisplay(pathId, index);

                // 更新所有花色收获奇观的得分
                updateAllSuitBonusWonders(pathId, card.suit);

                // 从手牌中移除卡牌
                gameState.hand.splice(selectedCardIndex, 1);

                // 重新渲染手牌
                renderHand();

                // 记录操作和奇观效果
                const wonderTierName = WONDER_TIERS[region.wonderData.tier].name;
                addLogEntry(`${t('occupy')}: ${PATH_NAMES[pathId]} ${region.rank} 奇观「${region.wonderData.name}」(${card.rank}${SUIT_SYMBOLS[card.suit]}) 即时+${wonderEffectResult.immediatePoints}分 ${wonderEffectResult.points > 0 ? '+' + wonderEffectResult.points + '分/回合' : ''} 效果: ${wonderEffectResult.effectDescription}`);

                // 显示消息
                showMessage(`占领奇观成功！获得${wonderEffectResult.immediatePoints}分，${wonderEffectResult.effectDescription}`);

                // 重置选择状态
                resetSelectionState();

                // 检查是否完成了整条路径的征服
                checkPathConquest(pathId); // 奇观占领也可能完成路径

                // 保存游戏状态到历史记录
                addToHistory(saveGameState());

                return; // 奇观处理完毕，退出函数
            }

            
           // 检查是否是遗忘区域 (现在允许占领)
            if (region.type === 'forgotten') {
                // 执行占领遗忘区域的逻辑
                region.status = 'occupied';
                region.occupyCard = card;
                region.points = 0; // 遗忘区域得分始终为0

                // 更新区域显示
                updateRegionDisplay(pathId, index);

                // 更新所有花色收获奇观的得分 (如果占领的牌花色触发了奇观效果)
                updateAllSuitBonusWonders(pathId, card.suit);


                // 从手牌中移除卡牌
                gameState.hand.splice(selectedCardIndex, 1);

                // 重新渲染手牌
                renderHand();

                // 记录操作
                addLogEntry(`${t('occupy')}: ${PATH_NAMES[pathId]} ${region.rank} 遗忘区域 (${card.rank}${SUIT_SYMBOLS[card.suit]}) +0分/回合`);

                // 显示消息
                showMessage(`占领遗忘区域成功！该区域不提供每回合得分。`); // 可以自定义消息

                // 重置选择状态
                resetSelectionState();

                // 检查是否完成了整条路径的征服
                checkPathConquest(pathId); // 占领遗忘区域也可能完成路径

                // 保存游戏状态到历史记录
                addToHistory(saveGameState());

                return; // 遗忘区域处理完毕，退出函数
            }



            // 以下是非奇观、非遗忘区域的常规占领逻辑 (standard, echo)

            let points = 0;
            let bonusInfo = '';

            if (region.type === 'standard') {
                // ... (标准区域占领逻辑，保持不变) ...
                points = REGION_TYPES.standard.occupyPoints;
                if (card.suit === 'heart') {
                    points = 2;
                    bonusInfo = `(${t('heartBonus')}: 1→2)`;
                }
            } else if (region.type === 'echo') {
                // ... (回声区域占领逻辑，保持不变) ...
                points = cardRank * 2;
                if (card.suit === 'heart') {
                    let originalPoints = points;
                    points = cardRank * 3;
                    bonusInfo = `(${t('heartBonus')}: ${originalPoints}→${points})`;
                }
                if (!bonusInfo) {
                    bonusInfo = t('echoBonus');
                } else {
                    bonusInfo += ` ${t('echoBonus')}`;
                }
            }

            // 更新区域状态
            region.status = 'occupied';
            region.occupyCard = card;
            region.points = points;

            // 更新区域显示
            updateRegionDisplay(pathId, index);

            // 更新所有花色收获奇观的得分显示
            updateAllSuitBonusWonders(pathId, card.suit); // 传递占领的路径和花色

            // 从手牌中移除卡牌
            gameState.hand.splice(selectedCardIndex, 1);

            // 重新渲染手牌
            renderHand();

            // 记录操作
            addLogEntry(`${t('occupy')}: ${PATH_NAMES[pathId]} ${region.rank} (${card.rank}${SUIT_SYMBOLS[card.suit]}) +${points}分/回合 ${bonusInfo}`);

            // 显示消息
            showMessage(t('occupyDone', {points: points}));

            // 重置选择状态
            resetSelectionState();

            // 检查是否完成了整条路径的征服
            checkPathConquest(pathId); // 常规占领也可能完成路径

            // 保存游戏状态到历史记录
            addToHistory(saveGameState());
        }
            
          // 更新区域显示
        function updateRegionDisplay(pathId, index) {
            const region = gameState.regions[pathId][index];
            const regionContainer = document.getElementById(`${pathId}-regions`);

            // 注意：我们倒序渲染了区域，所以索引需要调整
            const displayIndex = 12 - index;
            const regionElement = regionContainer.children[displayIndex];

            // 清空现有内容
            regionElement.innerHTML = '';

            // 更新样式
            regionElement.className = 'rounded-md w-16 h-24 md:w-20 md:h-30 border shadow-md flex flex-col items-center justify-center cursor-pointer relative';


            // 根据区域状态和类型设置基础样式
            if (region.status === 'unexplored') {
                regionElement.classList.add('bg-gray-400', 'dark:bg-gray-700');
            } else if (region.status === 'explored') {
                regionElement.classList.add('bg-white', 'dark:bg-gray-600'); // 已探索基础色
            } else if (region.status === 'occupied') {
                regionElement.classList.add('bg-blue-100', 'dark:bg-blue-800'); // 占领基础色
            }

            // 特殊类型样式覆盖基础样式 (奇观, 战争, 回声, 遗忘)
            if (region.type === 'wonder' && region.wonderData) {
                const tierClass = `wonder-${region.wonderData.tier}`;
                regionElement.classList.add(tierClass);
            } else if (region.type === 'combat' && region.combatData) {
                const tierClass = `combat-${region.combatData.tier}`;
                regionElement.classList.add(tierClass);
            } else if (region.type === 'echo' && region.status !== 'occupied') { // 回声图标只在非占领时显示，颜色在基础样式中
                regionElement.classList.add('bg-green-200', 'dark:bg-green-800'); // 回声区域颜色
            } else if (region.type === 'forgotten') {
                regionElement.classList.add('bg-gray-200', 'dark:bg-gray-700', 'opacity-75'); // 遗忘区域颜色
            }


            // 区域等级显示（顶部）
            const rankElement = document.createElement('div');
            rankElement.className = 'text-sm font-bold absolute top-1 left-1';
            rankElement.textContent = index + 1;
            regionElement.appendChild(rankElement);


            // 根据区域类型和状态添加不同的内容

            // --- 遗忘区域显示 (无论状态) ---
            if (region.type === 'forgotten') {
                const typeLabel = document.createElement('div');
                typeLabel.className = 'absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-xs font-bold text-gray-500 dark:text-gray-400';
                typeLabel.textContent = t('forgottenRegion');
                regionElement.appendChild(typeLabel);

                // 如果是占领状态，显示卡牌和0分
                if (region.status === 'occupied' && region.occupyCard) {
                    const card = region.occupyCard;
                    // 卡牌信息（中心或下方）
                    const cardInfo = document.createElement('div');
                    cardInfo.className = 'flex flex-col items-center justify-center mt-4'; // Add margin to not overlap label

                    const cardRank = document.createElement('div');
                    cardRank.className = 'text-base font-bold'; // Slightly larger for center
                    cardRank.textContent = card.rank;

                    const cardSuit = document.createElement('div');
                    cardSuit.className = `${card.suit} text-xl`; // Slightly larger for center
                    cardSuit.textContent = SUIT_SYMBOLS[card.suit];

                    cardInfo.appendChild(cardRank);
                    cardInfo.appendChild(cardSuit);
                    regionElement.appendChild(cardInfo);

                    // 得分显示（底部）- 遗忘区域始终是 +0
                    const pointsElement = document.createElement('div');
                    pointsElement.className = 'absolute bottom-1 right-1 text-xs font-bold bg-blue-200 dark:bg-blue-600 px-1 rounded';
                    pointsElement.textContent = `+0`;
                    regionElement.appendChild(pointsElement);
                }

            }
            // --- 奇观区域显示 (无论状态) ---
            else if (region.type === 'wonder' && region.wonderData) {
                // ... (奇观显示逻辑，保持不变) ...
                if (region.status === 'unexplored') {
                    const unknownElement = document.createElement('div');
                    unknownElement.className = 'text-lg font-bold text-white text-center';
                    unknownElement.textContent = '???';
                    regionElement.appendChild(unknownElement);
                } else if (region.status === 'explored') {
                    const nameElement = document.createElement('div'); nameElement.className = 'text-xs font-bold text-center px-1 mb-1'; nameElement.textContent = region.wonderData.name; regionElement.appendChild(nameElement);
                    const conditionElement = document.createElement('div'); conditionElement.className = 'text-xs text-center'; conditionElement.textContent = '需要: J、Q、K、A或红心'; regionElement.appendChild(conditionElement);
                    const effectElement = document.createElement('div'); effectElement.className = 'text-xs text-center mt-1 px-1'; const effectText = region.wonderData.effect.name; effectElement.textContent = `[${effectText}]`; regionElement.appendChild(effectElement);
                } else if (region.status === 'occupied') {
                    const nameElement = document.createElement('div'); nameElement.className = 'text-xs font-bold text-center px-1 mb-1'; nameElement.textContent = region.wonderData.name; regionElement.appendChild(nameElement);
                    if (region.occupyCard) {
                        const card = region.occupyCard; const cardElement = document.createElement('div'); cardElement.className = 'flex items-center justify-center'; const cardRank = document.createElement('div'); cardRank.className = 'text-sm font-bold'; cardRank.textContent = card.rank; const cardSuit = document.createElement('div'); cardSuit.className = `${card.suit} text-lg`; cardSuit.textContent = SUIT_SYMBOLS[card.suit]; cardElement.appendChild(cardRank); cardElement.appendChild(cardSuit); regionElement.appendChild(cardElement);
                    }
                    const effectElement = document.createElement('div'); effectElement.className = 'text-xs text-center mt-1 px-1'; const effectText = region.wonderData.effect.name; effectElement.textContent = `[${effectText}]`; regionElement.appendChild(effectElement);
                    if (region.points > 0) { // 只在奇观得分 > 0 时显示分数
                        const pointsElement = document.createElement('div'); pointsElement.className = 'absolute bottom-1 right-1 text-xs font-bold bg-blue-200 dark:bg-blue-600 px-1 rounded'; pointsElement.textContent = `+${region.points}`; regionElement.appendChild(pointsElement);
                    }
                }
            }
            // --- 战争区域显示 (无论状态) ---
            else if (region.type === 'combat' && region.combatData) {
                // ... (战争区域显示逻辑，保持不变) ...
                if (region.status === 'unexplored') {
                    const unknownElement = document.createElement('div');
                    unknownElement.className = 'text-lg font-bold text-white text-center';
                    unknownElement.textContent = '???';
                    regionElement.appendChild(unknownElement);
                } else if (region.status === 'explored') {
                    const nameElement = document.createElement('div'); nameElement.className = 'text-xs font-bold text-center px-1 mb-1'; nameElement.textContent = region.combatData.name; regionElement.appendChild(nameElement);
                    const conditionElement = document.createElement('div'); conditionElement.className = 'text-xs text-center'; conditionElement.textContent = region.combatData.requirement.display; regionElement.appendChild(conditionElement);
                    const effectElement = document.createElement('div'); effectElement.className = 'text-xs text-center mt-1 px-1 text-red-500 dark:text-red-400'; effectElement.textContent = region.combatData.effect.name; regionElement.appendChild(effectElement);
                    const clickPrompt = document.createElement('div'); clickPrompt.className = 'text-xs text-center mt-1 animate-pulse'; clickPrompt.textContent = t('clickToResolveCombat'); regionElement.appendChild(clickPrompt);
                }
            }
            // --- 其他区域 (standard, echo) 显示 ---
            else {
                // 状态标识 - 只有在非占领状态时才添加
                if (region.status !== 'occupied') {
                    const statusIndicator = document.createElement('div');
                    statusIndicator.className = 'absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-xs font-bold';
                    if (region.status === 'unexplored') {
                        statusIndicator.textContent = t('unexploredRegion');
                        statusIndicator.className += ' text-gray-100 dark:text-gray-300';
                    } else if (region.status === 'explored') {
                        statusIndicator.textContent = t('exploredRegion');
                        statusIndicator.className += ' text-green-600 dark:text-green-400';
                    }
                    regionElement.appendChild(statusIndicator);
                }

                // 回声区域标识 (无论状态，但在占领时可能与卡牌重叠，因此只在非占领时显示背景颜色区分，图标可以在占领后也显示)
                if (region.type === 'echo') {
                    const typeIndicator = document.createElement('div');
                    typeIndicator.className = 'absolute top-1 right-1 w-2 h-2 rounded-full bg-green-400 dark:bg-green-300'; // Echo icon
                    regionElement.appendChild(typeIndicator);
                }

                // 如果是占领状态，显示卡牌和得分
                if (region.status === 'occupied' && region.occupyCard) {
                    const card = region.occupyCard;

                    // 卡牌信息（中间）
                    const cardInfo = document.createElement('div');
                    cardInfo.className = 'flex flex-col items-center justify-center';

                    const cardRank = document.createElement('div');
                    cardRank.className = 'text-lg font-bold';
                    cardRank.textContent = card.rank;

                    const cardSuit = document.createElement('div');
                    cardSuit.className = `${card.suit} text-2xl`;
                    cardSuit.textContent = SUIT_SYMBOLS[card.suit];

                    cardInfo.appendChild(cardRank);
                    cardInfo.appendChild(cardSuit);
                    regionElement.appendChild(cardInfo);

                    // 得分显示（底部）
                    const pointsElement = document.createElement('div');
                    pointsElement.className = 'absolute bottom-1 right-1 text-xs font-bold bg-blue-200 dark:bg-blue-600 px-1 rounded';
                    pointsElement.textContent = `+${region.points}`;
                    regionElement.appendChild(pointsElement);
                }
            }
        }
            
            // 弃牌（支持多选）
            function discardCard() {
                if (gameState.selectedCards.length === 0) {
                    showMessage('请先选择要弃掉的手牌');
                    return;
                }
                
                // 按照索引从大到小排序（先处理后面的索引避免删除影响前面的索引）
                const sortedIndices = [...gameState.selectedCards].sort((a, b) => b - a);
                
                // 记录弃掉的牌
                const discardedCards = [];
                
                // 处理每张选中的牌
                for (const index of sortedIndices) {
                    // 获取选中的卡牌
                    const card = gameState.hand[index];
                    discardedCards.push(`${card.rank}${SUIT_SYMBOLS[card.suit]}`);
                    
                    // 加入弃牌堆
                    gameState.discardPile.push(card);
                    
                    // 从手牌中移除
                    gameState.hand.splice(index, 1);
                }
                
                // 更新弃牌堆计数
                updateDiscardCount();
                
                // 记录操作
                if (discardedCards.length === 1) {
                    addLogEntry(`弃牌: ${discardedCards[0]}`);
                } else {
                    addLogEntry(`弃牌: ${discardedCards.join(', ')}`);
                }
                
                // 重置选择状态
                resetSelectionState();
                
                // 重新渲染手牌
                renderHand();
                
                // 显示消息
                if (discardedCards.length === 1) {
                    showMessage(`已弃掉 ${discardedCards[0]}`);
                } else {
                    showMessage(`已弃掉 ${discardedCards.length} 张牌`);
                }
                
                // 保存游戏状态到历史记录
                addToHistory(saveGameState());
            }
            
            // 显示弃牌提示
            function showDiscardPrompt() {
                // 创建弹窗提示
                const promptOverlay = document.createElement('div');
                promptOverlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                
                const promptBox = document.createElement('div');
                promptBox.className = 'bg-white dark:bg-gray-800 p-5 rounded-lg shadow-lg max-w-md w-full mx-4 text-center';
                
                const title = document.createElement('h3');
                title.className = 'text-xl font-bold mb-3';
                title.textContent = '手牌已达上限';
                
                const message = document.createElement('p');
                message.className = 'mb-4';
                message.textContent = '您的手牌已达到上限(10张)。请先弃掉一些手牌，然后再结束回合。';
                
                const button = document.createElement('button');
                button.className = 'bg-primary hover:bg-indigo-700 text-white px-4 py-2 rounded-lg';
                button.textContent = '确定';
                button.addEventListener('click', () => {
                    document.body.removeChild(promptOverlay);
                });
                
                promptBox.appendChild(title);
                promptBox.appendChild(message);
                promptBox.appendChild(button);
                promptOverlay.appendChild(promptBox);
                
                document.body.appendChild(promptOverlay);
            }
            
            // 获取当前手牌上限
            function getCurrentHandLimit() {
                // 基础手牌上限
                let handLimit = 10;
                
                // 只有当游戏区域已经初始化时才计算奇观效果
                if (!gameState.regions || Object.keys(gameState.regions).length === 0) {
                    return handLimit;
                }
                
                // 计算奇观带来的手牌上限提升
                for (const pathId of PATHS) {
                    // 确保该路径存在且可迭代
                    if (gameState.regions[pathId] && Array.isArray(gameState.regions[pathId])) {
                        for (const region of gameState.regions[pathId]) {
                            if (region.status === 'occupied' && 
                                region.type === 'wonder' && 
                                region.wonderData && 
                                region.wonderEffect &&
                                region.wonderEffect.type === 'population') {
                                handLimit += region.wonderEffect.value;
                            }
                        }
                    }
                }
                
                return handLimit;
            }
            
            // 结束回合
            function endTurn() {
                // 获取当前手牌上限
                const currentHandLimit = getCurrentHandLimit();

                // 如果手牌已满且牌库还有牌，提示玩家先弃牌
                if (gameState.hand.length >= currentHandLimit && gameState.deck.length > 0) {
                    showDiscardPrompt();
                    return;
                }

                // --- 新增：处理未解除的战争区域 ---
                const unresolvedCombatZones = [];
                for (const pathId of PATHS) {
                    for (let i = 0; i < gameState.regions[pathId].length; i++) {
                        const region = gameState.regions[pathId][i];
                        // 查找已探索的战争区域且仍然阻塞下一格的区域
                        if (region.status === 'explored' &&
                            region.type === 'combat' &&
                            region.combatData &&
                            region.combatData.blocking) // 理论上已探索未解除的战争区blocking应该为true
                        {
                            unresolvedCombatZones.push({ pathId: pathId, index: i });
                        }
                    }
                }

                // 对每个未解除的战争区域应用惩罚并转换为遗忘区域
                if (unresolvedCombatZones.length > 0) {
                    addLogEntry("回合结束，处理未解除的战争区域...");
                    for (const { pathId, index } of unresolvedCombatZones) {
                        const region = gameState.regions[pathId][index];
                        // 调用处理惩罚的函数，这将应用效果并转换为遗忘区域
                        resolveCombatWithPenalty(pathId, index);
                        // resolveCombatWithPenalty 内部会更新区域状态和日志
                    }
                }
                // --- 新增结束 ---


                // 计算回合得分和奇观效果
                let turnPoints = 0;
                let extraDraws = 0;  // 记录奇观提供的额外抽牌次数
                let wonderEffects = []; // 记录激活的奇观效果
                let lossEffects = []; // 记录收入损失效果

                // 遍历所有区域，结算占领区域的分数和奇观效果
                for (const pathId of PATHS) {
                    // 计算当前路径的总收入（不含收入损失）
                    let pathIncome = 0;

                    for (const region of gameState.regions[pathId]) {
                        // 累计该路径的所有收入 (只计算占领区域)
                        if (region.status === 'occupied' && region.points > 0) {
                            pathIncome += region.points;
                        }

                        // 处理奇观特殊效果 (仅针对占领状态的奇观)
                        if (region.status === 'occupied' && region.type === 'wonder' && region.wonderData && region.wonderEffect) {
                            const effect = region.wonderEffect;

                            // 处理抽卡效果 (记录下来，稍后统一抽牌)
                            if (effect.type === 'draw') {
                                extraDraws += effect.value;
                                wonderEffects.push(`「${region.wonderData.name}」: 多抽${effect.value}张`);
                            }

                            // 处理花色加成效果 (重新计算分数并记录)
                            if (effect.type === 'suit_bonus') {
                                // 重新计算花色数量和得分
                                if (effect.formula === 'squared') {
                                    // 计算该路径上匹配花色的数量
                                    let suitCount = 0;
                                    for (const r of gameState.regions[effect.pathId]) {
                                        if (r.status === 'occupied' && r.occupyCard && r.occupyCard.suit === effect.suit) {
                                            suitCount++;
                                        }
                                    }

                                    // 使用对应倍率×n²公式计算得分
                                    const newPoints = effect.multiplier * (suitCount * suitCount);

                                    // 更新区域得分 (这个得分会在本次循环中的pathIncome += region.points;中被累加)
                                    region.points = newPoints;

                                    // 记录效果描述
                                    wonderEffects.push(`「${region.wonderData.name}」: ${PATH_NAMES[effect.pathId]}路径上${SUIT_SYMBOLS[effect.suit]}(${suitCount}个): ${newPoints}分/回合`);

                                    // 重新渲染这个奇观的显示，以更新分数
                                    // 我们在循环结束前统一更新区域显示，所以这里不需要
                                    // updateRegionDisplay(pathId, i); // 这里的 i 需要获取 region 在 pathId 数组中的实际索引
                                } else {
                                    // 如果是其他类型的花色收获效果 (虽然目前只有 squared)
                                    wonderEffects.push(`「${region.wonderData.name}」: ${PATH_NAMES[effect.pathId]}路径上的${SUIT_SYMBOLS[effect.suit]}收获效果 (计算已包含在得分中)`);
                                }
                            } else {
                                // Other wonder effects (draw, population, score, explore)
                                if (effect.type === 'draw') wonderEffects.push(`「${region.wonderData.name}」: 多抽${effect.value}张`);
                                if (effect.type === 'population') wonderEffects.push(`「${region.wonderData.name}」: 手牌上限+${effect.value}`);
                                if (effect.type === 'score') wonderEffects.push(`「${region.wonderData.name}」: 每回合+${region.points}分`); // Use region.points for score effect
                                if (effect.type === 'explore') { /* explore is immediate, log entry in processWonderEffects */ }
                            }
                            // 其他奇观效果（如人口）在 calculatePointsPerTurn 或 getCurrentHandLimit 中处理，不需要在这里累加分数
                        }
                    }

                    // --- 新增：结算掠夺惩罚 ---
                    if (gameState.pillagePenalties && gameState.pillagePenalties[pathId] && gameState.pillagePenalties[pathId].length > 0) {
                        // 累加该路径所有的掠夺倍率
                        const totalMultiplier = gameState.pillagePenalties[pathId].reduce((sum, mult) => sum + mult, 0);
                        // 计算损失点数 (路径收入 * 总倍率)，损失最多不超过当前路径总收入（收入不会变成负数）
                        const lossAmount = pathIncome * totalMultiplier; // 计算总损失点数
                        const actualLoss = lossAmount; // 实际损失点数 (目前没有特殊规则，实际损失等于计算出的损失)
                        //Math.min(lossAmount, pathIncome); // 实际损失不超过当前收入

                        if (actualLoss > 0) {
                            addLogEntry(`「掠夺」效果结算: ${PATH_NAMES[pathId]}路径收入 ${pathIncome}分，总倍率 ${totalMultiplier}x，实际损失 ${actualLoss}分`);
                            pathIncome -= actualLoss; // 从路径收入中扣除损失
                        } else if (lossAmount > 0) { // 如果损失点数 > 0 但实际损失为0 (因为 pathIncome 是 0)
                            addLogEntry(`「掠夺」效果结算: ${PATH_NAMES[pathId]}路径收入 ${pathIncome}分，总倍率 ${totalMultiplier}x，无实际收入损失`);
                        }
                        // 注意：即使 lossAmount 是 0 (例如 pathIncome 是 0)，recordPillagePenalty 仍然记录了惩罚触发日志。这里是结算日志。
                    }

                    // 将该路径的收入加入总得分
                    turnPoints += pathIncome;
                }


                gameState.pillagePenalties = {};

                // 重新渲染所有区域，确保花色收获奇观的分数更新显示
                updateAllRegionsDisplay();

                // 清除本回合的收入损失效果，因为已经处理过了
                gameState.incomeLoss = {};


                // 更新总分
                gameState.score += turnPoints;
                scoreDisplay.textContent = gameState.score;

                // 更新右下角信息栏 (包括每回合得分)
                updateCornerInfo();

                // 增加回合数
                gameState.turn++;
                turnCounter.textContent = gameState.turn;

                // 记录操作和奇观效果、收入损失
                let logMessage = `${t('turnEnded', {points: turnPoints})}`;
                if (wonderEffects.length > 0) {
                    logMessage += ` (奇观: ${wonderEffects.join(", ")})`;
                }
                /*
                if (lossEffects.length > 0) {
                    logMessage += ` (惩罚: ${lossEffects.join(", ")})`;
                }*/
                addLogEntry(logMessage);

                // 抽牌处理 - 先抽基础牌，然后抽奇观提供的额外牌
                let cardsDrawn = [];

                // 基础抽牌 - 每回合抽1张 (即使牌库空也尝试，drawCard会返回null)
                const baseDrawCard = drawCard();
                if (baseDrawCard) {
                    gameState.hand.push(baseDrawCard);
                    cardsDrawn.push(`${baseDrawCard.rank}${SUIT_SYMBOLS[baseDrawCard.suit]}`);
                }


                // 奇观额外抽牌
                for (let i = 0; i < extraDraws; i++) {
                    const extraCard = drawCard();
                    if (extraCard) {
                        gameState.hand.push(extraCard);
                        cardsDrawn.push(`${extraCard.rank}${SUIT_SYMBOLS[extraCard.suit]}`);
                    } else {
                        // 如果牌库抽空了，停止额外抽牌
                        break;
                    }
                }


                // 记录抽牌
                if (cardsDrawn.length > 0) {
                    const drawMessage = cardsDrawn.length === 1
                        ? `抽了一张牌: ${cardsDrawn[0]}`
                        : `抽了${cardsDrawn.length}张牌: ${cardsDrawn.join(", ")}`;
                    addLogEntry(drawMessage);
                } else if (gameState.deck.length === 0) {
                    // 如果牌库空了，且没有抽到牌，记录一下
                    addLogEntry(`牌库已空，没有抽到牌`);
                }


                // 重新渲染手牌
                renderHand();

                // 显示消息 (可以简化，主要信息已经在日志里)
                // showMessage(t('turnEnded', {points: turnPoints}));


                // 检查游戏是否结束
                checkGameOver();

                // 保存游戏状态到历史记录
                addToHistory(saveGameState());
            }
            
            /*
            // 检查游戏是否结束
            function checkGameOver() {
                // 如果没有牌可抽并且手牌为空，游戏结束
                if (gameState.deck.length === 0 && gameState.hand.length === 0) {
                    gameState.gameOver = true;
                    
                    // 显示结果弹窗
                    finalScoreDisplay.textContent = gameState.score;
                    resultModal.classList.remove('hidden');
                }
            }*/
            function checkGameOver() {
                if (gameState.turn > 80) {
                    gameState.gameOver = true;

                    // 显示结果弹窗
                    finalScoreDisplay.textContent = gameState.score;
                    resultModal.classList.remove('hidden');
                }
                    
            }
            
            // 创建并洗牌
            function createDeck() {
                const deck = [];
                
                for (const suit of SUITS) {
                    for (const rank of RANKS) {
                        deck.push({ suit, rank });
                    }
                }
                
                return deck;
            }
            
            // Fisher-Yates洗牌，使用seededRandom
            function shuffleDeck(deck) {
                const shuffled = [...deck];
                
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(seededRandom() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                
                return shuffled;
            }
            
            // 抽一张牌
            function drawCard() {
                if (gameState.deck.length === 0) {
                    return null;
                }
                
                remainingCardsDisplay.textContent = gameState.deck.length - 1;
                return gameState.deck.pop();
            }
            
            // 渲染手牌
            function renderHand() {
                // 获取当前手牌上限
                const currentHandLimit = getCurrentHandLimit();
                
                // 更新手牌上限显示
                const handLimitEl = document.getElementById('hand-limit');
                const rulesHandLimitEl = document.getElementById('rules-hand-limit');
                
                if (handLimitEl) handLimitEl.textContent = currentHandLimit;
                if (rulesHandLimitEl) rulesHandLimitEl.textContent = currentHandLimit;
                
                handContainer.innerHTML = '';
                
                if (gameState.hand.length === 0) {
                    const emptyText = document.createElement('div');
                    emptyText.className = 'text-gray-400 dark:text-gray-600 text-center w-full py-4';
                    emptyText.textContent = '没有手牌';
                    handContainer.appendChild(emptyText);
                } else {
                    gameState.hand.forEach((card, index) => {
                        const cardElement = document.createElement('div');
                        const isSelected = gameState.selectedCards.includes(index);
                        cardElement.className = `card hand-card transition-transform duration-200 w-16 h-24 md:w-20 md:h-30 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg shadow-md flex flex-col items-center justify-center ${isSelected ? 'border-primary border-2 -translate-y-4' : ''}`;
                        cardElement.dataset.index = index;
                        
                        // 卡牌内容
                        const rankElement = document.createElement('div');
                        rankElement.className = 'text-sm md:text-base';
                        rankElement.textContent = card.rank;
                        
                        const suitElement = document.createElement('div');
                        suitElement.className = `${card.suit} text-lg md:text-2xl`;
                        suitElement.textContent = SUIT_SYMBOLS[card.suit];
                        
                        cardElement.appendChild(rankElement);
                        cardElement.appendChild(suitElement);
                        
                        // 添加点击事件
                        cardElement.addEventListener('click', () => selectCard(index));
                        
                        handContainer.appendChild(cardElement);
                    });
                }
                
                // 更新手牌计数
                const handCountEl = document.getElementById('hand-count');
                if (handCountEl) {
                    handCountEl.textContent = gameState.hand.length;
                    
                    // 如果手牌接近上限，高亮显示
                    const warningThreshold = Math.max(8, currentHandLimit - 2); // 只有接近上限才显示警告
                    
                    if (gameState.hand.length >= warningThreshold) {
                        handCountEl.className = 'font-bold';
                        if (gameState.hand.length >= currentHandLimit) {
                            handCountEl.className += ' text-red-500 dark:text-red-400';
                        } else {
                            handCountEl.className += ' text-yellow-500 dark:text-yellow-400';
                        }
                    } else {
                        handCountEl.className = '';
                    }
                }
                
                // 更新弃牌按钮状态
                const discardBtn = document.getElementById('discard-btn');
                if (discardBtn) {
                    discardBtn.disabled = gameState.selectedCards.length === 0;
                    discardBtn.classList.toggle('opacity-50', gameState.selectedCards.length === 0);
                }
            }
            
            // 选择手牌（支持多选）
            function selectCard(index) {
                // 检查该牌是否已经被选中
                const cardIndex = gameState.selectedCards.indexOf(index);
                
                if (cardIndex !== -1) {
                    // 如果已经选中，取消选择
                    gameState.selectedCards.splice(cardIndex, 1);
                } else {
                    // 否则添加到选中列表
                    gameState.selectedCards.push(index);
                }
                
                // 更新选中卡牌数量显示
                const selectedCountEl = document.getElementById('selected-count');
                if (selectedCountEl) {
                    selectedCountEl.textContent = gameState.selectedCards.length;
                }
                
                // 更新操作信息提示
                if (gameState.selectedCards.length === 0) {
                    actionInfoElement.textContent = '';
                } else if (gameState.selectedCards.length === 1) {
                    const card = gameState.hand[gameState.selectedCards[0]];
                    actionInfoElement.textContent = `已选择: ${card.rank}${SUIT_SYMBOLS[card.suit]} - 点击区域执行操作`;
                } else {
                    actionInfoElement.textContent = `已选择 ${gameState.selectedCards.length} 张牌`;
                }
                
                // 更新弃牌按钮状态
                const discardBtn = document.getElementById('discard-btn');
                if (discardBtn) {
                    discardBtn.disabled = gameState.selectedCards.length === 0;
                    discardBtn.classList.toggle('opacity-50', gameState.selectedCards.length === 0);
                }
                
                // 重新渲染手牌，显示选中状态
                renderHand();
            }
            
            // 选择行动
            function selectAction(action) {
                // 如果已经选择了这个行动，取消选择
                if (gameState.selectedAction === action) {
                    resetSelectionState();
                } else {
                    gameState.selectedAction = action;
                    gameState.selectedCard = null; // 重置选中的卡牌
                    
                    // 更新按钮样式
                    document.getElementById('explore-btn').classList.toggle('ring-2', action === 'explore');
                    document.getElementById('occupy-btn').classList.toggle('ring-2', action === 'occupy');
                    
                    // 显示相关提示
                    if (action === 'explore') {
                        showMessage(t('infoSelectCardToExplore'));
                    } else if (action === 'occupy') {
                        showMessage(t('infoSelectCardToOccupy'));
                    }
                }
                
                // 更新操作信息
                updateActionInfo();
            }
            
            // 重置选择状态
            function resetSelectionState() {
                gameState.selectedAction = '';
                gameState.selectedCards = [];
                
                // 更新选中卡牌数量显示
                const selectedCountEl = document.getElementById('selected-count');
                if (selectedCountEl) {
                    selectedCountEl.textContent = 0;
                }
                
                // 重新渲染手牌
                renderHand();
                
                // 清空操作信息
                actionInfoElement.textContent = '';
            }
            
            // 更新操作信息
            function updateActionInfo() {
                if (!gameState.selectedAction) {
                    actionInfoElement.textContent = '';
                    return;
                }
                
                if (gameState.selectedCard === null) {
                    actionInfoElement.textContent = t('selectCard');
                } else {
                    const card = gameState.hand[gameState.selectedCard];
                    
                    if (gameState.selectedAction === 'explore') {
                        actionInfoElement.textContent = `探索: 使用 ${card.rank}${SUIT_SYMBOLS[card.suit]} 探索未占领区域`;
                    } else if (gameState.selectedAction === 'occupy') {
                        actionInfoElement.textContent = `占领: 使用 ${card.rank}${SUIT_SYMBOLS[card.suit]} 占领已探索区域`;
                    }
                }
            }
            
            // 显示消息
            function showMessage(message) {
                gameMessageElement.textContent = message;
                
                // 添加动画效果
                gameMessageElement.classList.add('text-primary');
                setTimeout(() => {
                    gameMessageElement.classList.remove('text-primary');
                }, 2000);
            }
            
            // 添加日志条目
            function addLogEntry(message) {
                const logEntry = document.createElement('div');
                logEntry.className = 'mb-1 pb-1 border-b border-gray-200 dark:border-gray-700';
                
                // 回合前缀
                const turnPrefix = document.createElement('span');
                turnPrefix.className = 'font-bold';
                turnPrefix.textContent = `[${gameState.turn}] `;
                
                logEntry.appendChild(turnPrefix);
                logEntry.appendChild(document.createTextNode(message));
                
                gameLogElement.insertBefore(logEntry, gameLogElement.firstChild);
                
                // 记录到日志数据
                gameLogData.push({
                    turn: gameState.turn,
                    message: message,
                    timestamp: new Date().toISOString(),
                    score: gameState.score
                });
            }
            
            // 保存游戏状态
            function saveGameState() {
                return {
                    deck: [...gameState.deck],
                    hand: [...gameState.hand],
                    discardPile: [...gameState.discardPile],
                    score: gameState.score,
                    turn: gameState.turn,
                    currentSeed: gameState.currentSeed,
                    regions: JSON.parse(JSON.stringify(gameState.regions)),
                    gameOver: gameState.gameOver,
                    conqueredPaths: gameState.conqueredPaths ? {...gameState.conqueredPaths} : {}, // Save conquered paths
                    pillagePenalties: gameState.pillagePenalties ? JSON.parse(JSON.stringify(gameState.pillagePenalties)) : {} // <-- 新增：保存掠夺惩罚
                };
            }

            
            // 将新状态添加到历史记录
            function addToHistory(state) {
                // 如果在历史中间点进行了新操作，删除该点之后的所有历史
                if (currentHistoryIndex >= 0 && currentHistoryIndex < history.length - 1) {
                    history = history.slice(0, currentHistoryIndex + 1);
                }
                
                // 添加新状态到历史记录
                history.push(state);
                currentHistoryIndex = history.length - 1;
                
                // 更新撤销按钮状态
                updateUndoButton();
            }
            
            // 恢复游戏状态
            function restoreGameState(state) {
                // 恢复所有游戏状态
                gameState.deck = [...state.deck];
                gameState.hand = [...state.hand];
                gameState.discardPile = [...state.discardPile];
                gameState.score = state.score;
                gameState.turn = state.turn;
                gameState.currentSeed = state.currentSeed;
                gameState.regions = JSON.parse(JSON.stringify(state.regions));
                gameState.gameOver = state.gameOver;
                gameState.conqueredPaths = state.conqueredPaths ? {...state.conqueredPaths} : {}; // Restore conquered paths
                gameState.pillagePenalties = state.pillagePenalties ? JSON.parse(JSON.stringify(state.pillagePenalties)) : {}; // <-- 新增：恢复掠夺惩罚

                // 重置选择状态
                resetSelectionState();
                
                // 更新UI
                scoreDisplay.textContent = gameState.score;
                turnCounter.textContent = gameState.turn;
                remainingCardsDisplay.textContent = gameState.deck.length;
                
                // 重新渲染手牌
                renderHand();
                
                // 更新所有区域显示
                updateAllRegionsDisplay();
                
                // 更新撤销按钮状态
                updateUndoButton();
                
                // 如果游戏结束，显示结果弹窗
                if (gameState.gameOver) {
                    finalScoreDisplay.textContent = gameState.score;
                    resultModal.classList.remove('hidden');
                } else {
                    resultModal.classList.add('hidden');
                }
            }
            
            // 更新所有区域显示
            function updateAllRegionsDisplay() {
                for (const pathId of PATHS) {
                    for (let i = 0; i < 13; i++) {
                        updateRegionDisplay(pathId, i);
                    }
                }
            }
            
            // 更新所有花色收获奇观的分数
            function updateAllSuitBonusWonders(changedPathId = null, changedSuit = null) {
                // 遍历所有路径寻找花色收获奇观
                for (const pathId of PATHS) {
                    for (let i = 0; i < 13; i++) {
                        const region = gameState.regions[pathId][i];
                        
                        // 检查是否是已占领的奇观且有花色收获效果
                        if (region.status === 'occupied' && 
                            region.type === 'wonder' && 
                            region.wonderData && 
                            region.wonderEffect && 
                            region.wonderEffect.type === 'suit_bonus') {
                            
                            const effect = region.wonderEffect;
                            
                            // 如果指定了changedPathId和changedSuit，只更新受影响的奇观
                            if (changedPathId && changedSuit) {
                                // 如果奇观监控的路径不是变更的路径，或者监控的花色不是变更的花色，则跳过
                                if (effect.pathId !== changedPathId || effect.suit !== changedSuit) {
                                    continue;
                                }
                            }
                            
                            // 计算该路径上匹配花色的数量
                            let suitCount = 0;
                            for (const r of gameState.regions[effect.pathId]) {
                                if (r.status === 'occupied' && r.occupyCard && r.occupyCard.suit === effect.suit) {
                                    suitCount++;
                                }
                            }
                            
                            // 根据奇观等级使用不同倍率计算新的得分
                            let multiplier;
                            if (region.wonderData.tier === 'orange') {
                                multiplier = 6; // 橙色奇观：6×n²
                            } else if (region.wonderData.tier === 'purple') {
                                multiplier = 4; // 紫色奇观：4×n²
                            } else {
                                multiplier = 3; // 蓝色奇观：3×n²
                            }
                            
                            const newPoints = multiplier * (suitCount * suitCount);
                            
                            // 如果得分发生变化，更新区域得分
                            if (region.points !== newPoints) {
                                region.points = newPoints;
                                // 更新区域显示
                                updateRegionDisplay(pathId, i);
                            }
                        }
                    }
                }
            }
            
            // 更新撤销按钮状态
            function updateUndoButton() {
                const undoBtn = document.getElementById('undo-btn');
                
                undoBtn.disabled = currentHistoryIndex <= 0;
                undoBtn.classList.toggle('opacity-50', currentHistoryIndex <= 0);
            }
            
            // 撤销操作
            function undoMove() {
                if (currentHistoryIndex > 0) {
                    currentHistoryIndex--;
                    restoreGameState(history[currentHistoryIndex]);
                }
            }
            
            // 创建一个种子随机数生成器
            function createSeededRandom(seed) {
                // 简单的哈希函数
                let hash = Array.from(seed).reduce((acc, char) => {
                    return ((acc << 5) - acc) + char.charCodeAt(0) | 0;
                }, 0);
                
                return function() {
                    const x = Math.sin(hash++) * 10000;
                    return x - Math.floor(x);
                };
            }
            
            // 显示提示信息
            function showToast(message) {
                toastElement.textContent = message;
                toastElement.classList.add('opacity-100');
                
                setTimeout(() => {
                    toastElement.classList.remove('opacity-100');
                }, 2000);
            }
            
            // 复制种子
            function copySeed() {
                navigator.clipboard.writeText(gameState.currentSeed).then(() => {
                    showToast(t('copied'));
                });
            }
            
            // 分享游戏
            function shareGame() {
                let shareUrl;
                
                // 处理 about:srcdoc 特殊情况（在 Poe 环境中）
                if (!window.location.href || window.location.href === "about:srcdoc") {
                    // 在 Poe iframe 中使用固定的 URL
                    shareUrl = "https://poe.com/4XPoker";
                } else {
                    // 在其他环境中使用当前 URL 的基础部分
                    const url = new URL(window.location.href);
                    shareUrl = url.origin + url.pathname;
                }
                
                // 使用 code 参数替代 seed 参数
                shareUrl += "?code=" + encodeURIComponent(gameState.currentSeed);
                
                const shareText = t('shareText', {
                    score: gameState.score,
                    seed: gameState.currentSeed
                });
                
                // 将完整的分享链接添加到文本末尾
                const fullShareText = `${shareText}\n${shareUrl}`;
                
                navigator.clipboard.writeText(fullShareText).then(() => {
                    showToast(t('copied'));
                }).catch(err => {
                    console.error('Share failed:', err);
                });
            }
            
            // 更新弃牌堆计数
            function updateDiscardCount() {
                const discardCountEl = document.getElementById('discard-count');
                if (discardCountEl) {
                    discardCountEl.textContent = gameState.discardPile.length;
                }
            }
            
            // 计算每回合总得分
            function calculatePointsPerTurn() {
                let totalPoints = 0;
                
                // 遍历所有区域，计算占领区域的分数
                for (const pathId of PATHS) {
                    for (const region of gameState.regions[pathId]) {
                        // 累加所有占领区域的得分
                        if (region.status === 'occupied' && region.points > 0) {
                            totalPoints += region.points;
                        }
                    }
                }
                
                return totalPoints;
            }
            
            // 更新右下角和浮动信息栏
            function updateCornerInfo() {
                // 右下角信息栏
                const scoreCorner = document.getElementById('score-corner');
                const turnCorner = document.getElementById('turn-corner');
                const remainingCorner = document.getElementById('remaining-corner');
                const discardCorner = document.getElementById('discard-corner');
                const pointsPerTurn = document.getElementById('points-per-turn');
                
                // 浮动信息栏
                const floatScore = document.getElementById('float-score');
                const floatTurn = document.getElementById('float-turn');
                const floatDeck = document.getElementById('float-deck');
                const floatDiscard = document.getElementById('float-discard');
                const floatPointsPerTurn = document.getElementById('float-points-per-turn');
                const estimatedScore = document.getElementById('estimated-score');
                
                // 计算每回合得分
                const points = calculatePointsPerTurn();
                
                // 更新右下角信息
                if (scoreCorner) scoreCorner.textContent = gameState.score;
                if (turnCorner) turnCorner.textContent = gameState.turn;
                if (remainingCorner) remainingCorner.textContent = gameState.deck.length;
                if (discardCorner) discardCorner.textContent = gameState.discardPile.length;
                
                // 更新每回合得分
                if (pointsPerTurn) {
                    pointsPerTurn.textContent = '+' + points;
                    
                    // 根据得分调整显示样式
                    if (points >= 300) {
                        pointsPerTurn.className = 'text-red-500 dark:text-red-400 font-bold';
                    } else if (points >= 200) {
                        pointsPerTurn.className = 'text-yellow-500 dark:text-yellow-400 font-bold';
                    } else if (points > 0) {
                        pointsPerTurn.className = 'text-green-600 dark:text-green-400 font-bold';
                    } else {
                        pointsPerTurn.className = 'text-gray-600 dark:text-gray-400';
                    }
                }
                
                // 更新浮动区域信息
                if (floatScore) floatScore.textContent = gameState.score;
                if (floatTurn) floatTurn.textContent = gameState.turn;
                if (floatDeck) floatDeck.textContent = gameState.deck.length;
                if (floatDiscard) floatDiscard.textContent = gameState.discardPile.length;
                
                // 更新浮动区域每回合得分
                if (floatPointsPerTurn) {
                    floatPointsPerTurn.textContent = '+' + points;
                    
                    // 根据得分调整显示样式
                    if (points >= 300) {
                        floatPointsPerTurn.className = 'text-red-500 dark:text-red-400 font-bold';
                    } else if (points >= 200) {
                        floatPointsPerTurn.className = 'text-yellow-500 dark:text-yellow-400 font-bold';
                    } else if (points > 0) {
                        floatPointsPerTurn.className = 'text-green-600 dark:text-green-400 font-bold';
                    } else {
                        floatPointsPerTurn.className = 'text-gray-600 dark:text-gray-400';
                    }
                }
                
                // 计算并更新预计得分
                if (estimatedScore) {
                    // 计算预计剩余回合数
                    // 回合数 = 剩余牌数 / 每回合起牌数
                    // 默认每回合起1张牌
                    let cardsPerTurn = 1;
                    
                    // 计算每回合额外抽牌数
                    let extraDraws = 0;
                    for (const pathId of PATHS) {
                        for (const region of gameState.regions[pathId]) {
                            if (region.status === 'occupied' && 
                                region.type === 'wonder' && 
                                region.wonderData && 
                                region.wonderEffect &&
                                region.wonderEffect.type === 'draw') {
                                extraDraws += region.wonderEffect.value;
                            }
                        }
                    }
                    
                    // 调整每回合起牌数
                    cardsPerTurn += extraDraws;
                    
                    // 计算预计剩余回合数（最少1回合）
                    //const estimatedRemainingTurns = Math.max(1, Math.ceil(gameState.deck.length / cardsPerTurn));
                    // 改为 80回合减去当前回合
                    const estimatedRemainingTurns = Math.max(0, Math.ceil(80 - gameState.turn));
                    
                    // 计算最终预计得分
                    const finalEstimatedScore = gameState.score + (points * estimatedRemainingTurns);
                    
                    // 更新预计得分显示
                    estimatedScore.textContent = finalEstimatedScore;
                    
                    // 根据预计得分调整显示样式
                    if (finalEstimatedScore >= 300) {
                        estimatedScore.className = 'text-red-500 dark:text-red-400 font-bold';
                    } else if (finalEstimatedScore >= 200) {
                        estimatedScore.className = 'text-yellow-500 dark:text-yellow-400 font-bold';
                    } else if (finalEstimatedScore >= 100) {
                        estimatedScore.className = 'text-green-500 dark:text-green-400 font-bold';
                    } else {
                        estimatedScore.className = 'text-yellow-600 dark:text-yellow-400';
                    }
                }
            }
            
            // 开始新游戏
            function startGame(seed = null) {
                // 生成或使用提供的种子
                gameState.currentSeed = seed || crypto.randomUUID();
                seedDisplay.textContent = gameState.currentSeed;
                
                // 初始化随机数生成器
                seededRandom = createSeededRandom(gameState.currentSeed);
                
                // 重置游戏状态
                gameState.deck = createDeck();
                gameState.deck = shuffleDeck(gameState.deck);
                gameState.hand = [];
                gameState.discardPile = [];
                gameState.score = 0;
                gameState.turn = 1;
                gameState.gameOver = false;
                
                // 重置选择状态
                resetSelectionState();
                
                // 初始化游戏区域
                initializeGameRegions();
                
                // 抽5张起始手牌
                for (let i = 0; i < 5; i++) {
                    if (gameState.deck.length > 0) {
                        gameState.hand.push(drawCard());
                    }
                }
                
                // 更新UI
                scoreDisplay.textContent = gameState.score;
                turnCounter.textContent = gameState.turn;
                remainingCardsDisplay.textContent = gameState.deck.length;
                updateDiscardCount();
                
                // 更新右下角信息栏
                updateCornerInfo();
                
                // 渲染手牌
                renderHand();
                
                // 隐藏结果弹窗
                resultModal.classList.add('hidden');
                
                // 重置游戏日志
                gameLogElement.innerHTML = '';
                gameLogData = [];
                
                // 添加游戏开始日志
                addLogEntry(t('gameStart'));
                
                // 重置历史记录并保存初始状态
                history = [];
                currentHistoryIndex = -1;
                addToHistory(saveGameState());
            }
            
            // 检查是否完成了整条路径的征服
            function checkPathConquest(pathId) {
                // 首先检查该路径是否已经被完全征服
                const path = gameState.regions[pathId];
                const allOccupied = path.every(region => region.status === 'occupied');
                
                // 如果路径已经被完全征服，且没有被标记为已征服
                if (allOccupied && !(gameState.conqueredPaths && gameState.conqueredPaths[pathId])) {
                    // 初始化已征服路径记录
                    if (!gameState.conqueredPaths) {
                        gameState.conqueredPaths = {};
                    }
                    
                    // 如果该路径已经被征服，则返回
                    if (gameState.conqueredPaths[pathId]) {
                        return;
                    }
                    
                    // 标记该路径为已征服
                    gameState.conqueredPaths[pathId] = true;
                    
                    // 计算奖励分数
                    // 1. 基于随机种子选择一个花色
                    const suitIndex = Math.floor(seededRandom() * SUITS.length);
                    const randomSuit = SUITS[suitIndex];
                    
                    // 2. 计算该路径上该花色的数量
                    let suitCount = 0;
                    for (const region of path) {
                        if (region.occupyCard && region.occupyCard.suit === randomSuit) {
                            suitCount++;
                        }
                    }
                    
                    // 3. 计算奖励分数: 200 * num^2
                    const bonusPoints = 200 * (suitCount * suitCount);
                    
                    // 更新游戏总分
                    gameState.score += bonusPoints;
                    scoreDisplay.textContent = gameState.score;
                    
                    // 更新右下角信息栏
                    updateCornerInfo();
                    
                    // 准备并显示征服成就信息
                    const pathName = PATH_NAMES[pathId];
                    const conquestMessages = {
                        'land': `您征服了整个${pathName}！大地在您的脚下臣服，文明的种子已经遍布每一寸土地。`,
                        'ocean': `您征服了整个${pathName}！浩瀚的海洋已成为您的领地，舰队所向披靡。`,
                        'desert': `您征服了整个${pathName}！荒芜之地也绽放出您文明的花朵，没有任何地方能阻挡您的扩张。`,
                        'sky': `您征服了整个${pathName}！您的民族已经掌握了制空权，从云端俯瞰整个世界。`
                    };
                    
                    // 显示征服弹窗
                    const conquestModal = document.getElementById('conquest-modal');
                    const conquestMessage = document.getElementById('conquest-message');
                    const conquestPoints = document.getElementById('conquest-points');
                    
                    conquestMessage.textContent = conquestMessages[pathId];
                    conquestPoints.textContent = bonusPoints;
                    conquestModal.classList.remove('hidden');
                    
                    // 添加关闭按钮事件
                    document.getElementById('conquest-close').addEventListener('click', () => {
                        conquestModal.classList.add('hidden');
                    }, { once: true });
                    
                    // 记录到游戏日志
                    const suitSymbol = SUIT_SYMBOLS[randomSuit];
                    addLogEntry(`<span class="font-bold text-yellow-500">【${pathName}征服者】</span> 征服了整个${pathName}！奖励: +${bonusPoints}分 (200×${suitSymbol}数量²，${suitCount}个${suitSymbol})`);
                }
            }
            
            // 翻译函数
            function t(key, replacements = {}) {
                let text = LANGUAGES[currentLanguage][key] || LANGUAGES['en'][key] || key;
                
                // 应用替换
                for (const [placeholder, value] of Object.entries(replacements)) {
                    text = text.replace(`{${placeholder}}`, value);
                }
                
                return text;
            }
            
            // 检测用户的浏览器语言
            function detectBrowserLanguage() {
                const browserLang = navigator.language || navigator.userLanguage;
                const shortLang = browserLang.split('-')[0];
                
                // 检查是否有完全匹配
                if (LANGUAGES[browserLang]) {
                    return browserLang;
                }
                
                // 检查语言匹配
                for (const lang in LANGUAGES) {
                    if (lang.startsWith(shortLang)) {
                        return lang;
                    }
                }
                
                // 默认为中文
                return 'zh-CN';
            }
            
            // 应用翻译
            function applyTranslations() {
                document.querySelectorAll('[data-i18n]').forEach(element => {
                    const key = element.getAttribute('data-i18n');
                    element.textContent = t(key);
                });
            }
            
            // 检查暗黑模式
            function checkDarkMode() {
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    document.documentElement.classList.add('dark');
                }
                
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                    if (event.matches) {
                        document.documentElement.classList.add('dark');
                    } else {
                        document.documentElement.classList.remove('dark');
                    }
                });
            }
            
            // 初始化事件监听器
            function setupEventListeners() {
                // 新游戏按钮
                document.getElementById('new-game-btn').addEventListener('click', () => startGame());
                
                // 撤销按钮
                document.getElementById('undo-btn').addEventListener('click', undoMove);
                
                // 结束回合按钮
                document.getElementById('end-turn-btn').addEventListener('click', endTurn);
                
                // 弃牌按钮
                document.getElementById('discard-btn').addEventListener('click', discardCard);
                
                // 复制种子按钮
                document.getElementById('copy-seed').addEventListener('click', copySeed);
                
                // 分享游戏按钮
                document.getElementById('share-game').addEventListener('click', shareGame);
                
                // 顶部种子输入框随机种子按钮
                document.getElementById('random-seed-btn').addEventListener('click', () => {
                    const newSeed = crypto.randomUUID();
                    const seedInput = document.getElementById('seed-input');
                    seedInput.value = newSeed;
                    seedInput.classList.add('bg-yellow-100', 'dark:bg-yellow-900');
                    setTimeout(() => {
                        seedInput.classList.remove('bg-yellow-100', 'dark:bg-yellow-900');
                    }, 1000);
                });
                
                // 顶部种子输入框开始游戏按钮
                document.getElementById('start-seed-game').addEventListener('click', () => {
                    const seedInput = document.getElementById('seed-input');
                    const seed = seedInput.value.trim();
                    if (seed) {
                        startGame(seed);
                        // 更新游戏控制区的种子显示
                        seedDisplay.textContent = seed;
                    } else {
                        seedInput.classList.add('border-red-500');
                        setTimeout(() => {
                            seedInput.classList.remove('border-red-500');
                        }, 1000);
                    }
                });
                
                // 种子输入框回车键触发开始游戏
                document.getElementById('seed-input').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('start-seed-game').click();
                    }
                });
                
                // 随机种子按钮（顶部信息区）
                document.getElementById('random-seed').addEventListener('click', () => {
                    const newSeed = crypto.randomUUID();
                    // 更新显示和游戏状态中的种子
                    seedDisplay.textContent = newSeed;
                    gameState.currentSeed = newSeed;
                    
                    // 同时更新种子输入框
                    const seedInput = document.getElementById('seed-input');
                    if (seedInput) {
                        seedInput.value = newSeed;
                    }
                    
                    // 高亮显示提示已更新
                    seedDisplay.classList.add('bg-yellow-100', 'dark:bg-yellow-900');
                    setTimeout(() => {
                        seedDisplay.classList.remove('bg-yellow-100', 'dark:bg-yellow-900');
                    }, 1000);
                });
                
                // 显示输入种子弹窗
            function showSeedInputPrompt() {
                // 创建弹窗提示
                const promptOverlay = document.createElement('div');
                promptOverlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                
                const promptBox = document.createElement('div');
                promptBox.className = 'bg-white dark:bg-gray-800 p-5 rounded-lg shadow-lg max-w-md w-full mx-4';
                
                const title = document.createElement('h3');
                title.className = 'text-xl font-bold mb-3 text-center';
                title.textContent = '输入种子';
                
                const message = document.createElement('p');
                message.className = 'mb-4 text-sm text-gray-600 dark:text-gray-400';
                message.textContent = '输入一个种子值来开始相同的游戏，或使用当前种子重玩。';
                
                const inputContainer = document.createElement('div');
                inputContainer.className = 'mb-4';
                
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200';
                input.placeholder = '输入种子值';
                input.value = gameState.currentSeed;
                input.spellcheck = false;
                
                inputContainer.appendChild(input);
                
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'flex justify-between gap-3';
                
                const startButton = document.createElement('button');
                startButton.className = 'bg-primary hover:bg-indigo-700 text-white px-4 py-2 rounded-lg flex-1';
                startButton.textContent = '开始游戏';
                startButton.addEventListener('click', () => {
                    const seed = input.value.trim();
                    if (seed) {
                        document.body.removeChild(promptOverlay);
                        startGame(seed);
                    } else {
                        input.classList.add('border-red-500');
                    }
                });
                
                const cancelButton = document.createElement('button');
                cancelButton.className = 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 px-4 py-2 rounded-lg flex-1';
                cancelButton.textContent = '取消';
                cancelButton.addEventListener('click', () => {
                    document.body.removeChild(promptOverlay);
                });
                
                buttonContainer.appendChild(startButton);
                buttonContainer.appendChild(cancelButton);
                
                promptBox.appendChild(title);
                promptBox.appendChild(message);
                promptBox.appendChild(inputContainer);
                promptBox.appendChild(buttonContainer);
                promptOverlay.appendChild(promptBox);
                
                document.body.appendChild(promptOverlay);
                
                // 自动聚焦输入框
                setTimeout(() => {
                    input.focus();
                    input.select();
                }, 100);
                
                // 添加按回车键提交
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        startButton.click();
                    }
                });
            }
            
            // 输入种子按钮
            document.getElementById('input-seed').addEventListener('click', () => {
                showSeedInputPrompt();
            });
                
                // 游戏结束弹窗的按钮
                document.getElementById('play-again').addEventListener('click', () => startGame());
                document.getElementById('replay-same-seed').addEventListener('click', () => startGame(gameState.currentSeed));
                document.getElementById('share-result').addEventListener('click', shareGame);
                
                // 历史浏览器按钮
                document.getElementById('history-btn').addEventListener('click', () => {
                    // 显示历史浏览器
                    const historyModal = document.getElementById('history-modal');
                    if (historyModal) {
                        historyModal.classList.remove('hidden');
                    }
                });
                
                // 历史浏览器的取消按钮
                document.getElementById('history-cancel').addEventListener('click', () => {
                    const historyModal = document.getElementById('history-modal');
                    if (historyModal) {
                        historyModal.classList.add('hidden');
                    }
                });
            }
            
            // 初始化
            function init() {
                // 设置当前语言
                currentLanguage = detectBrowserLanguage();
                
                // 应用翻译
                applyTranslations();
                
                // 检查暗黑模式
                checkDarkMode();
                
                // 设置事件监听器
                setupEventListeners();
                
                // 检查URL是否包含种子参数（支持code或seed参数）
                let seedFromURL = null;
                try {
                    const urlParams = new URLSearchParams(window.location.search);
                    // 优先使用code参数，如果没有则尝试使用seed参数
                    seedFromURL = urlParams.get('code') || urlParams.get('seed');
                } catch (error) {
                    console.error("Error parsing URL parameters:", error);
                }
                
                // 如果有URL种子，同时更新种子输入框
                if (seedFromURL) {
                    const seedInput = document.getElementById('seed-input');
                    if (seedInput) {
                        seedInput.value = seedFromURL;
                    }
                }
                
                // 开始游戏
                startGame(seedFromURL);
            }

            function renderHistoryBoard(state) {
                const historyBoardElement = document.getElementById('history-board');
                if (!historyBoardElement) return;

                historyBoardElement.innerHTML = ''; // 清空面板

                // 创建路径标题
                const pathTitles = document.createElement('div');
                pathTitles.className = 'grid grid-cols-4 gap-2 mb-2 text-center';
                // 注意：这里需要调整宽度，使其与下方区域格子对齐
                pathTitles.style.width = 'fit-content'; // 或者一个固定的宽度
                pathTitles.style.margin = '0 auto'; // 居中

                PATHS.forEach(pathId => {
                    const title = document.createElement('div');
                    title.className = `text-white rounded px-1 py-1 text-center font-bold text-xs w-16 md:w-20 mx-auto flex items-center justify-center bg-${pathId}`; // 使用路径颜色
                    title.textContent = PATH_NAMES[pathId]; // 使用翻译的路径名称
                    pathTitles.appendChild(title);
                });
                historyBoardElement.appendChild(pathTitles);


                // 创建区域容器，模拟主游戏区域的结构
                const gameAreaContainer = document.createElement('div');
                gameAreaContainer.className = 'flex justify-center';
                const regionsGrid = document.createElement('div');
                regionsGrid.className = 'grid grid-cols-4 gap-2';
                regionsGrid.style.width = 'fit-content'; // 或者一个固定的宽度

                // 为每条路径创建列容器
                const pathContainers = {};
                PATHS.forEach(pathId => {
                    pathContainers[pathId] = document.createElement('div');
                    pathContainers[pathId].className = 'flex flex-col gap-1';
                    regionsGrid.appendChild(pathContainers[pathId]);
                });

                // 遍历所有区域，并渲染到对应的路径容器中 (倒序渲染)
                PATHS.forEach(pathId => {
                    const pathRegions = state.regions[pathId];
                    for (let i = 12; i >= 0; i--) { // 从13到1
                        const region = pathRegions[i];
                        const regionElement = document.createElement('div');

                        // 使用与主游戏区域相同的尺寸和基础样式
                        regionElement.className = 'rounded-md w-16 h-24 md:w-20 md:h-30 border shadow-md flex flex-col items-center justify-center relative';

                        // 根据区域状态和类型设置样式 (复制 updateRegionDisplay 中的逻辑)
                        if (region.status === 'unexplored') {
                            regionElement.classList.add('bg-gray-400', 'dark:bg-gray-700');
                        } else if (region.status === 'explored') {
                            regionElement.classList.add('bg-white', 'dark:bg-gray-600');
                            if (region.type === 'forgotten') {
                                regionElement.classList.add('bg-gray-200', 'dark:bg-gray-700', 'opacity-75');
                            }
                        } else if (region.status === 'occupied') {
                            regionElement.classList.add('bg-blue-100', 'dark:bg-blue-800');
                        }

                        if (region.type === 'echo' && region.status !== 'occupied') {
                            regionElement.classList.add('bg-green-200', 'dark:bg-green-800');
                        }
                        if (region.type === 'wonder' && region.wonderData) {
                            const tierClass = `wonder-${region.wonderData.tier}`;
                            regionElement.classList.add(tierClass);
                        }
                        if (region.type === 'combat' && region.combatData) {
                            const tierClass = `combat-${region.combatData.tier}`;
                            regionElement.classList.add(tierClass);
                        }


                        // 区域等级显示
                        const rankElement = document.createElement('div');
                        rankElement.className = 'text-sm font-bold absolute top-1 left-1';
                        rankElement.textContent = i + 1; // 显示数字1-13
                        regionElement.appendChild(rankElement);


                        // 根据区域类型和状态添加不同的内容 (复制 updateRegionDisplay 中的逻辑)
                        if (region.type === 'wonder' && region.wonderData) {
                            if (region.status === 'unexplored') {
                                const unknownElement = document.createElement('div');
                                unknownElement.className = 'text-lg font-bold text-white text-center';
                                unknownElement.textContent = '???';
                                regionElement.appendChild(unknownElement);
                            }
                            else if (region.status === 'explored') {
                                const nameElement = document.createElement('div');
                                nameElement.className = 'text-xs font-bold text-center px-1 mb-1';
                                nameElement.textContent = region.wonderData.name;
                                regionElement.appendChild(nameElement);

                                const conditionElement = document.createElement('div');
                                conditionElement.className = 'text-xs text-center';
                                conditionElement.textContent = '需要: J、Q、K、A或红心';
                                regionElement.appendChild(conditionElement);

                                const effectElement = document.createElement('div');
                                effectElement.className = 'text-xs text-center mt-1 px-1';
                                const effectText = region.wonderData.effect.name;
                                effectElement.textContent = `[${effectText}]`;
                                regionElement.appendChild(effectElement);
                            }
                            else if (region.status === 'occupied') {
                                const nameElement = document.createElement('div');
                                nameElement.className = 'text-xs font-bold text-center px-1 mb-1';
                                nameElement.textContent = region.wonderData.name;
                                regionElement.appendChild(nameElement);

                                if (region.occupyCard) {
                                    const card = region.occupyCard;
                                    const cardElement = document.createElement('div');
                                    cardElement.className = 'flex items-center justify-center';
                                    const cardRank = document.createElement('div'); cardRank.className = 'text-sm font-bold'; cardRank.textContent = card.rank;
                                    const cardSuit = document.createElement('div'); cardSuit.className = `${card.suit} text-lg`; cardSuit.textContent = SUIT_SYMBOLS[card.suit];
                                    cardElement.appendChild(cardRank); cardElement.appendChild(cardSuit); regionElement.appendChild(cardElement);
                                }
                                const effectElement = document.createElement('div');
                                effectElement.className = 'text-xs text-center mt-1 px-1';
                                const effectText = region.wonderData.effect.name;
                                effectElement.textContent = `[${effectText}]`;
                                regionElement.appendChild(effectElement);

                                if (region.points > 0) {
                                    const pointsElement = document.createElement('div');
                                    pointsElement.className = 'absolute bottom-1 right-1 text-xs font-bold bg-blue-200 dark:bg-blue-600 px-1 rounded';
                                    pointsElement.textContent = `+${region.points}`;
                                    regionElement.appendChild(pointsElement);
                                }
                            }
                        }
                        else if (region.type === 'combat' && region.combatData) {
                            if (region.status === 'unexplored') {
                                const unknownElement = document.createElement('div');
                                unknownElement.className = 'text-lg font-bold text-white text-center';
                                unknownElement.textContent = '???';
                                regionElement.appendChild(unknownElement);
                            } else if (region.status === 'explored') {
                                const nameElement = document.createElement('div');
                                nameElement.className = 'text-xs font-bold text-center px-1 mb-1';
                                nameElement.textContent = region.combatData.name;
                                regionElement.appendChild(nameElement);
                                const conditionElement = document.createElement('div');
                                conditionElement.className = 'text-xs text-center';
                                conditionElement.textContent = region.combatData.requirement.display;
                                regionElement.appendChild(conditionElement);
                                const effectElement = document.createElement('div');
                                effectElement.className = 'text-xs text-center mt-1 px-1 text-red-500 dark:text-red-400';
                                effectElement.textContent = region.combatData.effect.name;
                                regionElement.appendChild(effectElement);
                                // No click prompt in history view
                            }
                        }
                        else if (region.type === 'forgotten') {
                            const statusIndicator = document.createElement('div');
                            statusIndicator.className = 'absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-xs font-bold';
                            statusIndicator.textContent = t('forgottenRegion');
                            statusIndicator.className += ' text-gray-500 dark:text-gray-400';
                            regionElement.appendChild(statusIndicator);
                        }
                        else { // standard, echo
                            if (region.status !== 'occupied') {
                                const statusIndicator = document.createElement('div');
                                statusIndicator.className = 'absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-xs font-bold';
                                if (region.status === 'unexplored') {
                                    statusIndicator.textContent = t('unexploredRegion');
                                    statusIndicator.className += ' text-gray-100 dark:text-gray-300';
                                } else if (region.status === 'explored') {
                                    statusIndicator.textContent = t('exploredRegion');
                                    statusIndicator.className += ' text-green-600 dark:text-green-400';
                                }
                                regionElement.appendChild(statusIndicator);
                            }
                            if (region.type === 'echo') {
                                const typeIndicator = document.createElement('div');
                                typeIndicator.className = 'absolute top-1 right-1 w-2 h-2 rounded-full bg-green-400 dark:bg-green-300';
                                regionElement.appendChild(typeIndicator);
                            }
                            if (region.status === 'occupied' && region.occupyCard) {
                                const card = region.occupyCard;
                                const cardInfo = document.createElement('div');
                                cardInfo.className = 'flex flex-col items-center justify-center';
                                const cardRank = document.createElement('div'); cardRank.className = 'text-lg font-bold'; cardRank.textContent = card.rank;
                                const cardSuit = document.createElement('div'); cardSuit.className = `${card.suit} text-2xl`; cardSuit.textContent = SUIT_SYMBOLS[card.suit];
                                cardInfo.appendChild(cardRank); cardInfo.appendChild(cardSuit); regionElement.appendChild(cardInfo);

                                const pointsElement = document.createElement('div');
                                pointsElement.className = 'absolute bottom-1 right-1 text-xs font-bold bg-blue-200 dark:bg-blue-600 px-1 rounded';
                                pointsElement.textContent = `+${region.points}`;
                                regionElement.appendChild(pointsElement);
                            }
                        }


                        pathContainers[pathId].appendChild(regionElement);
                    }
                });

                gameAreaContainer.appendChild(regionsGrid);
                historyBoardElement.appendChild(gameAreaContainer);
            }

            // 在历史浏览器打开时调用此函数
            document.getElementById('history-btn').addEventListener('click', () => {
                const historyModal = document.getElementById('history-modal');
                if (historyModal) {
                    // 重置浏览索引到当前状态
                    currentBrowsingIndex = currentHistoryIndex;
                    updateHistoryDisplay(); // 更新历史浏览器显示

                    historyModal.classList.remove('hidden');
                }
            });

            // 更新历史浏览器显示的函数
            function updateHistoryDisplay() {
                if (currentBrowsingIndex < 0 || currentBrowsingIndex >= history.length) {
                    console.error("Invalid history index:", currentBrowsingIndex);
                    return;
                }

                const state = history[currentBrowsingIndex];
                const historyTurnEl = document.getElementById('history-turn');
                const historyIndexEl = document.getElementById('history-index');
                const historyTotalEl = document.getElementById('history-total');
                const historyScoreEl = document.getElementById('history-score');
                const historyActionDescEl = document.getElementById('history-action-desc');
                const historyPrevBtn = document.getElementById('history-prev');
                const historyNextBtn = document.getElementById('history-next');


                historyTurnEl.textContent = state.turn;
                historyIndexEl.textContent = currentBrowsingIndex;
                historyTotalEl.textContent = history.length -1; // 显示总操作数 (初始状态索引0不计入操作)
                historyScoreEl.textContent = state.score;

                // TODO: Fetch and display action description based on index and previous state? Or store descriptions in history?
                // For now, display the log message for this step (if available).
                // The gameLogData records *after* the action, so index 'i' corresponds to the state *after* logData[i-1]'s action.
                const logIndex = currentBrowsingIndex > 0 ? currentBrowsingIndex -1 : 0; // Initial state (0) has no action description
                if (gameLogData.length > logIndex) {
                    historyActionDescEl.textContent = currentBrowsingIndex === 0 ? "游戏开始" : gameLogData[logIndex].message.replace(/<[^>]*>/g, ''); // 移除HTML标签
                } else {
                    historyActionDescEl.textContent = "---";
                }


                renderHistoryBoard(state); // 渲染面板

                // 更新前进/后退按钮状态
                historyPrevBtn.disabled = currentBrowsingIndex <= 0;
                historyPrevBtn.classList.toggle('opacity-50', currentBrowsingIndex <= 0);
                historyNextBtn.disabled = currentBrowsingIndex >= history.length - 1;
                historyNextBtn.classList.toggle('opacity-50', currentBrowsingIndex >= history.length - 1);
            }


            // 添加历史浏览器前进/后退按钮事件
            document.getElementById('history-prev').addEventListener('click', () => {
                if (currentBrowsingIndex > 0) {
                    currentBrowsingIndex--;
                    updateHistoryDisplay();
                }
            });

            document.getElementById('history-next').addEventListener('click', () => {
                if (currentBrowsingIndex < history.length - 1) {
                    currentBrowsingIndex++;
                    updateHistoryDisplay();
                }
            });

            // 历史浏览器选择当前状态按钮
            document.getElementById('history-select').addEventListener('click', () => {
                if (currentBrowsingIndex >= 0 && currentBrowsingIndex < history.length) {
                    // 恢复到选中的历史状态
                    currentHistoryIndex = currentBrowsingIndex; // 设置当前历史索引
                    restoreGameState(history[currentHistoryIndex]); // 恢复游戏状态

                    // 关闭历史浏览器
                    const historyModal = document.getElementById('history-modal');
                    if (historyModal) {
                        historyModal.classList.add('hidden');
                    }

                    // 提示用户已恢复状态
                    showMessage(`已恢复到回合 ${gameState.turn} 的状态`);
                }
            });
            
            // 当页面加载完成后初始化游戏
            window.addEventListener('DOMContentLoaded', init);
        </script>
    </div>
</body>
</html>
